# JAFG UE Fork

Is required to be able to modify plugins located in the project `./Mods/` directory
as they are not correctly loaded in the solution file generated by the Unreal Automation Tool.

Fork URL:

```
https://github.com/mzoesch/ue-rel
```

Requires access to epics private repo.

# Staged Source Modifications

All engine modifications are marked with a `// <JAFG>` comment
for the modification beginning and a `// </JAFG>` comment for the end.

## Ignore Rider Plugin files with engine ini

`.gitignore`

```.gitignore
# Configs
Engine/Config/DefaultEngine.ini

# Plugins
Engine/Plugins/Marketplace/Developer/RiderLink/
```

## Change Target Rules for Unreal Game Target to link their modules to individual dynamic libraries

`./Engine/Source/UnrealGame.Target.cs::UnrealGameTarget::UnrealGameTarget`

```csharp
// <JAFG>
LinkType = TargetLinkType.Modular;
// </JAFG>
```

## Scan Mods directory plugins

`./Engine/Source/Programs/Shared/EpicGames.Build/System/Rules.cs::Rules::FindAllRulesSourceFiles`

`-> foreach (DirectoryReference RootFolder in RootFolders) { ... }`

```csharp
// <JAFG> Scan Mods Folder plugins too
DirectoryReference ModsFolder = DirectoryReference.Combine(RootFolder, "Mods");
foreach (FileReference PluginFile in PluginsBase.EnumeratePlugins(ModsFolder))
{
    Folders.Add(DirectoryReference.Combine(PluginFile.Directory, "Source"));
}
// </JAFG>
```

## Add modification targets to all project target files

`./Engine/Source/Programs/UnrealBuildTool/ProjectFiles/ProjectFileGenerator.cs::ProjectFileGenerator::GenerateProjectFiles`

`-> List<Tuple<ProjectFile, ProjectTarget>> AllProjectTargetFiles = new List<Tuple<ProjectFile, ProjectTarget>>(); { ... }`

```csharp
// <JAFG> Modification targets
foreach (ProjectFile ModProject in ModProjects)
{
    foreach (ProjectTarget ProjectTarget in ModProject.ProjectTargets)
    {
        if (ProjectTarget.TargetFilePath != null)
        {
            // Only bother with the editor target.  We want to make sure that definitions are setup to be as inclusive as possible
            // for good quality IntelliSense.  For example, we want WITH_EDITORONLY_DATA=1, so using the editor targets works well.
            if (ProjectTarget.TargetRules == null)
            {
                Logger.LogError("ProjectTarget.TargetRules is null for {ProjectTarget}", ProjectTarget);
            }
            else if (ProjectTarget.TargetRules.Type == TargetType.Editor)
            {
                IntelliSenseTargetFiles.Add(Tuple.Create(ModProject, ProjectTarget));
            }
        }
    }
}
// </JAFG>
```

## Launch game (New File / UAT Command)

Allows to directly launch the game after modifications were done (for plugins only of course) in Steam.

`./Engine/Source/Programs/AutomationTool/Scripts/LaunchGame.cs`

## Compile Single Plugins (New File / UAT Command)

Allows to compile single plugins and copy them to the Mods directory in a binary version of the game. Can then automatically launch the game as stated above.

`./Engine/Source/Programs/AutomationTool/Scripts/PackagePlugin.cs`

## JSON .uproject Variable Expansion

Defines new metadata used to determine game plugins (basically mods; but often referred to game plugins) behavior
and how they should be loaded into the game at startup.

`./Engine/Source/Runtime/Projects/Public/PluginDescriptor.h::FPluginDescriptor`

```cpp
// <JAFG> Added custom fields for plugin descriptor
/** The range for which this plugin is compatible with JAFG. */
FString JAFGVersionRange;
/** The range for which this plugin is compatible with clients that have different versions. */
FString RemoteVersionRange;
/** The client will not be forced to have this plugin installed and enabled. */
bool bRequiredOnServer;
/** A client may have this plugin enabled, but the server will not care if bRequireOnServer is false. */
bool bRequiredOnClient;
/** May be removed or added at any given time, without destroying existing world data. */
bool bOptional;
// </JAFG>
```

## JSON .uproject Variable Serialization

Describes how the new metadata is serialized and deserialized.

`./Engine/Source/Runtime/Projects/Private/PluginDescriptor.cpp::FPluginDescriptor::Read(const FSjonObject&, FText*)`

Deserialization:

```cpp
// <JAFG> Deserialize custom fields
Object.TryGetStringField(TEXT("JAFGVersionRange"), JAFGVersionRange);
Object.TryGetStringField(TEXT("RemoteVersionRange"), RemoteVersionRange);
Object.TryGetBoolField(TEXT("bRequiredOnServer"), bRequiredOnServer);
Object.TryGetBoolField(TEXT("bRequiredOnClient"), bRequiredOnClient);
Object.TryGetBoolField(TEXT("bOptional"), bOptional);
// </JAFG>
```

Serialization:

`./Engine/Source/Runtime/Projects/Private/PluginDescriptor.cpp::FPluginDescriptor::UpdateJson(FSjonObject&) const`

```cpp
// <JAFG> Serialize custom fields
if (JAFGVersionRange.IsEmpty() == false)
{
    JsonObject.SetStringField(TEXT("JAFGVersionRange"), JAFGVersionRange);
}
else
{
    JsonObject.RemoveField(TEXT("JAFGVersionRange"));
}

if (RemoteVersionRange.IsEmpty() == false)
{
    JsonObject.SetStringField(TEXT("RemoteVersionRange"), RemoteVersionRange);
}
else
{
    JsonObject.RemoveField(TEXT("RemoteVersionRange"));
}

if (bRequiredOnServer)
{
    JsonObject.SetBoolField(TEXT("bRequiredOnServer"), bRequiredOnServer);
}
else
{
    JsonObject.RemoveField(TEXT("bRequiredOnServer"));
}

if (bRequiredOnClient)
{
    JsonObject.SetBoolField(TEXT("bRequiredOnClient"), bRequiredOnClient);
}
else
{
    JsonObject.RemoveField(TEXT("bRequiredOnClient"));
}

if (bOptional)
{
    JsonObject.SetBoolField(TEXT("bOptional"), bOptional);
}
else
{
    JsonObject.RemoveField(TEXT("bOptional"));
}
// </JAFG>
```
