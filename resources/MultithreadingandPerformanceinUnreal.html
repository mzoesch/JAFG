<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=iMc4-4exjgqA-toZgqqJBZTPmCyPtD5kCyAtRlF_KtD9-YwI2Pt9ZUilmW_RWu-z);ol{margin:0;padding:0}table td,table th{padding:0}.c1{background-color:#1e1e1e;margin-left:-7.1pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-7.3pt;height:10pt}.c50{margin-left:-7.1pt;padding-top:0pt;padding-bottom:3pt;line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c2{margin-left:-7.1pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-7.3pt;height:10pt}.c23{margin-left:-7.1pt;padding-top:12pt;padding-bottom:4pt;line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c33{margin-left:-7.1pt;padding-top:0pt;padding-bottom:12pt;line-height:0.06;orphans:2;widows:2;text-align:left;margin-right:-7.3pt;height:10pt}.c52{margin-left:-35.4pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-37.5pt;height:10pt}.c5{background-color:#1e1e1e;margin-left:-7.1pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c29{margin-left:-7.1pt;padding-top:22pt;padding-bottom:4pt;line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c7{margin-left:-7.1pt;padding-top:18pt;padding-bottom:4pt;line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c51{margin-left:-7.1pt;padding-top:28pt;padding-bottom:6pt;line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c16{margin-left:-7.1pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-7.3pt}.c56{margin-left:-7.1pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:right;margin-right:-7.3pt}.c31{color:#f1c232;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c30{color:#ffffff;font-weight:500;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Open Sans";font-style:normal}.c22{color:#f1c232;font-weight:500;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Open Sans";font-style:italic}.c24{font-weight:500;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Open Sans";font-style:italic}.c37{font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Open Sans";font-style:normal}.c36{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c48{color:#ffffff;text-decoration:none;vertical-align:baseline;font-size:26pt;font-style:normal}.c49{color:#787878;text-decoration:none;vertical-align:baseline;font-size:9pt;font-style:normal}.c53{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Courier New"}.c45{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c10{font-family:"Courier New";font-style:italic;color:#85c46c;font-weight:400}.c17{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#4a86e8;text-decoration:underline}.c6{text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c28{font-family:"Courier New";color:#3c3c3c;font-weight:400}.c4{font-family:"Courier New";color:#bdbdbd;font-weight:400}.c21{text-decoration:none;vertical-align:baseline;font-size:10pt}.c11{font-family:"Courier New";color:#ed94c0;font-weight:400}.c13{font-family:"Courier New";color:#39cc8f;font-weight:400}.c15{font-family:"Courier New";color:#b5cea8;font-weight:400}.c8{font-family:"Courier New";color:#787878;font-weight:400}.c14{font-family:"Courier New";color:#6c95eb;font-weight:400}.c55{background-color:#222327;max-width:510.4pt;padding:35.4pt 42.5pt 35.4pt 42.5pt}.c0{font-family:"Courier New";color:#ffd49e;font-weight:400}.c9{color:#d9d9d9;font-weight:500;font-family:"Open Sans"}.c19{color:#ff0000;font-weight:500;font-family:"Open Sans"}.c32{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c43{color:#85c46c;font-weight:400;font-family:"Courier New"}.c18{font-family:"Courier New";color:#e1bfff;font-weight:400}.c39{font-family:"Courier New";color:#c9a26d;font-weight:400}.c3{font-family:"Courier New";color:#d0d0d0;font-weight:400}.c46{font-family:"Open Sans";font-weight:700}.c54{color:#787878;font-style:normal}.c12{color:inherit;text-decoration:inherit}.c58{color:#39cc8f;font-style:normal}.c57{color:#bdbdbd;font-style:normal}.c26{font-size:10pt;font-style:normal}.c59{color:#85c46c;font-style:normal}.c38{font-weight:500;font-family:"Open Sans"}.c41{color:#8769e0}.c34{font-style:italic}.c40{color:#e69138}.c27{color:#e06666}.c35{color:#6d9eeb}.c47{color:#f1c232}.c20{color:#93c47d}.c25{color:#4a86e8}.c44{color:#d9d9d9}.c42{color:#00ffff}.title{padding-top:0pt;color:#ffffff;font-weight:500;font-size:26pt;padding-bottom:3pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-weight:500;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#d9d9d9;font-weight:500;font-size:10pt;font-family:"Open Sans"}p{margin:0;color:#d9d9d9;font-weight:500;font-size:10pt;font-family:"Open Sans"}h1{padding-top:28pt;color:#ffffff;font-weight:500;font-size:20pt;padding-bottom:6pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#d9d9d9;font-weight:500;font-size:16pt;padding-bottom:6pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:22pt;color:#93c47d;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:18pt;color:#93c47d;font-weight:500;font-size:12pt;padding-bottom:4pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-weight:500;font-size:11pt;padding-bottom:4pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#93c47d;font-weight:500;font-size:11pt;padding-bottom:4pt;font-family:"Open Sans";line-height:1.0;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c55 doc-content"><div><p class="c52"><span class="c6 c9"></span></p></div><p class="c50 title" id="h.rqad6hj69m0s"><span class="c38 c48">Multithreading and Performance in Unreal</span></p><p class="c16"><span class="c38 c49">BASTIEN CRUETTE</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">There&rsquo;s a criminal lack of condensed documentation on how to implement actually useful multithreading in Unreal, and also a general difficulty to find a good overview of practices that lead to performant code, so here&rsquo;s that.</span></p><h1 class="c51" id="h.d0864g38c74r"><span>MULTITHREADING</span></h1><h3 class="c29" id="h.l2reo28si4bc"><span class="c37 c27">1. Overview</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>Unreal </span><span>by default supports multithreading, but only makes partial use of it. While there are dedicated threads for audio, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.0/en-US/threaded-rendering-in-unreal-engine/&amp;sa=D&amp;source=editors&amp;ust=1712085893351007&amp;usg=AOvVaw0u8wwDQ2oRK2QsIYz_gA58">render</a></span><span class="c6 c9">&nbsp;and stats, most operations are still done in the game thread, including EventTicks and blueprints, while the rendering follows one or two frames behind the main thread, meaning that most expensive calculations will invariably lead to loss of framerate. That&rsquo;s where threading comes in handy!</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">There are two major approaches to async work in Unreal:</span></p><h6 class="c23" id="h.xoi9dr28ry34"><span class="c24 c27">Runnables</span></h6><p class="c16"><span class="c6 c9">Run on dedicated, newly created threads, to which you have full control over. They will automatically stop once their work is completed, and are generally useful for big computations that require a nearly continuously running thread.</span></p><h6 class="c23" id="h.ium2rt4ioj87"><span class="c24 c27">Tasks</span></h6><p class="c16"><span>Run on the </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.0/en-US/tasks-systems-in-unreal-engine/&amp;sa=D&amp;source=editors&amp;ust=1712085893351980&amp;usg=AOvVaw35NCX9T17c60HgQSGLbMTc">TaskGraph</a></span><span class="c6 c9">, a job manager that tries to balance out workload along multiple preexisting threads. This is ideal to send packages of small operations, as it abstracts away from you the complexity of managing threads, and also supports defining dependencies between Tasks.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Queuing Tasks will not cause performance concerns due to the threads being already running, but the system may also be less reactive as it has to find slots to fit the work in inside a limited pool, and sending long Tasks should be avoided to not clog-up threads. It may also sometimes decide to run Tasks directly in the game thread, depending on the setup.</span></p><h3 class="c29" id="h.2b4i75clkvky"><span class="c37 c40">2. Threading Classes</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Here&rsquo;s a brief of the common classes provided by the engine&rsquo;s Core:</span></p><h4 class="c7" id="h.q8x7d7slfnk3"><span class="c36 c40">FRunnable</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>The most comprehensive threading tool of Unreal. Simply derive a class from </span><span class="c13">FRunnable</span><span>&nbsp;</span><span class="c6 c9">like thus: </span></p><p class="c5"><span class="c10">// .h</span></p><p class="c5"><span class="c6 c8">#pragma once</span></p><p class="c5"><span class="c8">#include </span><span class="c6 c39">&quot;CoreMinimal.h&quot;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">class </span><span class="c13">FMyThread </span><span class="c3">: </span><span class="c8">public </span><span class="c13">FRunnable </span><span class="c4">{</span></p><p class="c5"><span class="c3">&nbsp; </span><span class="c0">FMyThread</span><span class="c4">( </span><span class="c10">/*Parameters*/ </span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c11">Thread </span><span class="c4">= </span><span class="c13">FRunnableThread</span><span class="c3">::</span><span class="c0">Create</span><span class="c4">(</span><span class="c8">this</span><span class="c4">, </span><span class="c8">TEXT</span><span class="c4">(</span><span class="c39">&quot;MyThread&quot;</span><span class="c6 c4">));</span></p><p class="c5"><span class="c6 c4">&nbsp; };</span></p><p class="c5"><span class="c13">&nbsp; </span></p><p class="c5"><span class="c8">&nbsp; virtual bool </span><span class="c0">Init</span><span class="c4">() </span><span class="c8">override</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">virtual </span><span class="c13">uint32 </span><span class="c0">Run</span><span class="c4">() </span><span class="c8">override</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">virtual void </span><span class="c0">Exit</span><span class="c4">() </span><span class="c8">override</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">virtual void </span><span class="c0">Stop</span><span class="c4">() </span><span class="c8">override</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">&nbsp; FRunnableThread</span><span class="c4">* </span><span class="c11">Thread</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">&nbsp; bool </span><span class="c11">bShutdown</span><span class="c4">= </span><span class="c8">false</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c5"><span class="c10">// .cpp</span></p><p class="c5"><span class="c8">#include </span><span class="c39">&quot;FMyThread.h&quot;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">bool </span><span class="c13">FMyThread</span><span class="c3">::</span><span class="c0">Init</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c10">&nbsp; /* Should the thread start? */</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return true</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">uint32 FMyThread</span><span class="c3">::</span><span class="c0">Run</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">while </span><span class="c4">(!</span><span class="c11">bShutdown</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c10">/* Work on a dedicated thread */</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">void </span><span class="c13">FMyThread</span><span class="c3">::</span><span class="c0">Exit</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10">/* Post-Run code, threaded */</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">void </span><span class="c13">FMyThread</span><span class="c3">::</span><span class="c0">Stop</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c11">bShutdown </span><span class="c4">= </span><span class="c8">true</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">When you want to start your thread, include its header and call its constructor (keep the pointer at hand!):</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">Thread </span><span class="c3">= </span><span class="c8">new </span><span class="c0">FMyThread</span><span class="c4">( </span><span class="c10">/*Parameters*/ </span><span class="c6 c4">);</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>That constructor in turn calls </span><span class="c13">FRunnableThread</span><span class="c3">::</span><span class="c0">Create</span><span class="c4">()</span><span>, with </span><span class="c8">this</span><span>&nbsp;</span><span>(i.e. your </span><span class="c13">FMyThread</span><span class="c6 c9">) as the FRunnable to be created.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The class provides four functions to override (automatically run by the class), in which you can implement your threaded code:</span></p><p class="c16"><span>- </span><span class="c0">Init</span><span class="c4">()</span><span>: Gets called by </span><span class="c13">FRunnableThread</span><span class="c3">::</span><span class="c0">Create</span><span class="c4">()</span><span>, runs in the game thread. Insert logic of your choice to decide whether or not the thread should initialize, return true if yes.</span></p><p class="c16"><span>- </span><span class="c0">Run</span><span class="c4">()</span><span>: Runs in the new thread, once </span><span class="c0">Init</span><span class="c4">()</span><span>&nbsp;has completed. Do your implementation here. When the function ends, the thread will naturally exit, so you might want some form of loop to iterate until your calculations are done, or you&rsquo;ve told your thread to stop (ex. with a boolean). The default return value is 0 for successful.</span></p><p class="c16"><span>- </span><span class="c0">Exit</span><span class="c4">()</span><span>: Runs in the new thread, once </span><span class="c0">Run</span><span class="c4">()</span><span>&nbsp;has completed. If you want special logic to occur there.</span></p><p class="c16"><span>- </span><span class="c0">Stop</span><span class="c4">()</span><span>: A normal function running in the game thread that does not get called automatically. Use </span><span class="c11">Thread</span><span class="c4">-&gt;</span><span class="c0">Kill</span><span class="c4">()</span><span>&nbsp;to run it in the event you want to end your thread early in a controlled manner. It&rsquo;s then up to you to implement how that happens (in this example by stopping the while loop). You can also call &nbsp;</span><span class="c11">Thread</span><span class="c4">-&gt;</span><span class="c0">Kill</span><span class="c4">(</span><span class="c8">false</span><span class="c4">)</span><span class="c6 c9">&nbsp;to forcefully terminate the thread.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>That is all you need, this will run by itself on a standalone thread and do your computations there. More info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://store.algosyntax.com/tutorials/unreal-engine/ue5-multithreading-with-frunnable-and-thread-workflow/&amp;sa=D&amp;source=editors&amp;ust=1712085893361126&amp;usg=AOvVaw3JQOONtKqQGLqoCAfl5KTl">there</a></span><span>, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://unrealcommunity.wiki/multithreading-with-frunnable-2a4xuf68&amp;sa=D&amp;source=editors&amp;ust=1712085893361287&amp;usg=AOvVaw3CYJ5VeU0dA54aAzpWJEp5">there</a></span><span class="c25">&nbsp;</span><span>and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://ue4wiki.imzlp.com/mediawikiv2-website-prod05.ol.epicgames.net/indexab7b.html?title%3DMulti-Threading:_How_to_Create_Threads_in_UE4&amp;sa=D&amp;source=editors&amp;ust=1712085893361526&amp;usg=AOvVaw1fgXjK2dm8grR73k11GjYX">there</a></span><span class="c6 c9">.</span></p><h4 class="c7" id="h.b958mm4sbk7a"><span class="c36 c40">AsyncTask</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>If you want to run a small async operation without creating a dedicated class or starting a new thread and do not need the control logic for pausing or callbacks, you can put it inside an </span><span class="c13">AsyncTask</span><span>&nbsp;running on the TaskGraph</span><span class="c6 c9">:</span></p><p class="c5"><span class="c13">AsyncTask</span><span class="c4">(</span><span class="c8">ENamedThreads</span><span class="c3">::</span><span class="c15">AnyHiPriThreadNormalTask</span><span class="c4">, [</span><span class="c8">this</span><span class="c6 c4">] () {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10 c21">/* Work on the TaskGraph */</span></p><p class="c5"><span class="c11 c34">&nbsp; </span><span class="c11">Caller</span><span class="c4">-&gt;</span><span class="c0">FunctionToThread</span><span class="c4">(); </span><span class="c10 c21">// Function call captured using [this]</span></p><p class="c5"><span class="c6 c4">});</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The structure here is similar to a </span><span class="c13">TFunction</span><span>, which is Unreal&rsquo;s way of implementing C++ lambdas. That means you need to capture references or copies of all variables or functions declared outside the AsyncTask, usually using </span><span class="c4">[</span><span class="c8">this</span><span class="c4">]</span><span>&nbsp;for member variables and </span><span class="c4">[&amp;]</span><span>&nbsp;for locals (see </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893363179&amp;usg=AOvVaw2SMo2Kg_cJatAJx-Jcnw6P">lambdas</a></span><span class="c25">&nbsp;</span><span>in C++).</span></p><p class="c2"><span class="c6 c8"></span></p><p class="c16"><span class="c8">ENamedThreads</span><span>&nbsp;gives you multiple choices for where you want to execute that threaded work, including back onto the game thread if calling from outside it. Since code is run on mostly preexisting Tasks in the TaskGraph, queuing numerous short Tasks has lower overhead than creating new </span><span class="c13">FRunnable</span><span>&nbsp;threads, but they may execute with more delay.</span></p><h4 class="c7" id="h.uswol75sefjs"><span class="c36 c40">ParallelFor</span></h4><hr><p class="c33"><span class="c6 c38 c40"></span></p><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://isaratech.com/ue4-improving-speed-with-parallelfor/&amp;sa=D&amp;source=editors&amp;ust=1712085893363947&amp;usg=AOvVaw046ODcVAEsG6yvq-1B6bxW">fancier</a></span><span>&nbsp;version of </span><span class="c13">AsyncTask</span><span class="c6 c9">&nbsp;that splits a for loop into multiple Tasks running in the TaskGraph.</span></p><p class="c5"><span class="c13">ParallelFor</span><span class="c4">(</span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Num</span><span class="c4">(), [&amp;](</span><span class="c13">int32 </span><span class="c14">i</span><span class="c4">) { </span><span class="c10">// Run Array.Num() operations, with current index i</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10">/* Work on the TaskGraph (order of execution is variable!) */</span></p><p class="c5"><span class="c4">&nbsp; ++</span><span class="c14">Array</span><span class="c4">[</span><span class="c14">i</span><span class="c6 c4">]; </span></p><p class="c5"><span class="c6 c4">});</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>There&rsquo;s no guarantee about the order or the thread safety of the operation within, so you might want to use mutexes or atomics with it. MSVC has </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/preprocessor/loop?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893365042&amp;usg=AOvVaw1b15tw872pVS3dt6oS7ujy">an analogous</a></span><span>&nbsp;</span><span class="c8">#pragma </span><span class="c3">loop</span><span class="c4">(</span><span class="c3">hint_parallel</span><span class="c4">(</span><span class="c3">n</span><span class="c4">))</span><span>. Practically speaking, the contents of your loop must be significant to really benefit from this approach.</span></p><h4 class="c7" id="h.73n8nhsr64k"><span class="c36 c40">FNonAbandonableTask</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">A way to declare your own AsyncTasks, in a format that sits inbetween FRunnable and lambda-like AsyncTasks. You can implement your own code in a standalone class to be more reusable, which will run on the TaskGraph instead of inside a dedicated thread, but missing some of FRunnable&rsquo;s initializing and stopping logic.</span></p><p class="c5"><span class="c6 c8">#pragma once</span></p><p class="c5"><span class="c8">#include </span><span class="c6 c39">&quot;CoreMinimal.h&quot;</span></p><p class="c1"><span class="c6 c39"></span></p><p class="c5"><span class="c8">class </span><span class="c13">FMyTask </span><span class="c3">: </span><span class="c8">public </span><span class="c13">FNonAbandonableTask </span><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">friend class </span><span class="c13">FAutoDeleteAsyncTask</span><span class="c4">&lt;</span><span class="c13">FMyTask</span><span class="c6 c4">&gt;;</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c0">FMyTask</span><span class="c4">( </span><span class="c10">/*Parameters*/ </span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c10 c21">/ Constructor */</span></p><p class="c5"><span class="c10">&nbsp; </span><span class="c6 c4">}</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">void </span><span class="c0">DoWork</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c10">/* Work on the TaskGraph */</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">FORCEINLINE TStatId </span><span class="c0">GetStatId</span><span class="c4">() </span><span class="c8">const </span><span class="c4">{ </span><span class="c10">// Probably declares the Task to the TaskGraph</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="c4">(</span><span class="c3">FMyTask</span><span class="c4">, </span><span class="c3">STATGROUP_ThreadPoolAsyncTasks</span><span class="c6 c4">);</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Start your custom Task like such:</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">MyTask </span><span class="c4">= </span><span class="c8">new </span><span class="c13">FAsyncTask</span><span class="c4">&lt;</span><span class="c13">FMyTask</span><span class="c4">&gt;( </span><span class="c10">/*Parameters*/ </span><span class="c6 c4">);</span></p><p class="c5"><span class="c14">MyTask</span><span class="c4">-&gt;</span><span class="c0">StartBackgroundTask</span><span class="c4">();</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The Task can be declared as a friend of </span><span class="c13">FAsyncTask</span><span>&nbsp;or </span><span class="c13">FAutoDeleteAsyncTask</span><span>, with the latter being more self-managing. More info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://jdelezenne.github.io/Codex/UE4/Multithreading.html&amp;sa=D&amp;source=editors&amp;ust=1712085893368836&amp;usg=AOvVaw2LpUrJvKrPnKVe4u1fe4cU">there</a></span><span class="c25">&nbsp;</span><span>and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://michaeljcole.github.io/wiki.unrealengine.com/Using_AsyncTasks/&amp;sa=D&amp;source=editors&amp;ust=1712085893369005&amp;usg=AOvVaw20nLdKmamD0dgsBiXIfKSc">there</a></span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>If you are extremely lazy and don&rsquo;t want to port your slow blueprints to C++,</span><span class="c25">&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3D0Yyh3oQgonI&amp;sa=D&amp;source=editors&amp;ust=1712085893369311&amp;usg=AOvVaw1A-AgNaNBqc_NHwAIUa5k3">it is also possible to make an AsyncTask run blueprints</a></span><span class="c25">&nbsp;</span><span class="c6 c9">through events.</span></p><h4 class="c7" id="h.lg1qz2bx8fzx"><span class="c36 c40">FFunctionGraphTask and TGraphTask</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Async/FFunctionGraphTask/&amp;sa=D&amp;source=editors&amp;ust=1712085893369775&amp;usg=AOvVaw2Kp0le_Zu48PFRk4FgWWbo">FFunctionGraphTask</a></span><span>&nbsp;is another</span><span>&nbsp;way to queue Tasks using lambdas, with a single prerequisite and completion action as optionals.</span></p><p class="c5"><span class="c13">FGraphEventRef </span><span class="c14">PrerequisiteTask</span><span class="c4">; </span><span class="c10">// A task to be completed before</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">FGraphEventRef </span><span class="c14">Task </span><span class="c4">= </span><span class="c13">FFunctionGraphTask</span><span class="c3">::</span><span class="c0">CreateAndDispatchWhenReady</span><span class="c4">( []()</span><span class="c28">&nbsp;</span><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10 c21">/* Work on the TaskGraph */</span></p><p class="c5"><span class="c4">}, </span><span class="c8">TStatId</span><span class="c4">(), </span><span class="c14">PrerequisiteTask</span><span class="c4">, </span><span class="c8">ENamedThreads</span><span class="c3">::</span><span class="c15">AnyThread</span><span class="c6 c4">);</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">FGraphEventArray </span><span class="c14">TasksList</span><span class="c4">; </span><span class="c14">TasksList</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c14">Task</span><span class="c6 c4">);</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">if </span><span class="c4">(</span><span class="c14">Task</span><span class="c4">-&gt;</span><span class="c0">IsComplete</span><span class="c6 c4">()) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10 c21">/* On work completed */</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Async/TGraphTask/&amp;sa=D&amp;source=editors&amp;ust=1712085893371931&amp;usg=AOvVaw3DtCiC1R0e1IiAVCfw54S1">TGraphTask</a></span><span>&nbsp;takes an entire user-defined class and adds it to the queue, with an optional list of prerequisites. You need to implement your own </span><span class="c0">DoTask</span><span class="c4">()</span><span>&nbsp;function within your class for it to work. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.casualdistractiongames.com/post/2018/12/10/unreal-tick-functions-delta-time-and-the-task-graph&amp;sa=D&amp;source=editors&amp;ust=1712085893372206&amp;usg=AOvVaw3LvDbBKwg3HIuPpQ52ncw_">More info</a></span><span>&nbsp;and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://ue4wiki.imzlp.com/mediawikiv2-website-prod05.ol.epicgames.net/index84c3.html?title%3DMulti-Threading:_Task_Graph_System&amp;sa=D&amp;source=editors&amp;ust=1712085893372385&amp;usg=AOvVaw1EhYKtiXarmys37mdKxerQ">an example</a></span><span>.</span></p><p class="c5"><span class="c13">FGraphEventRef </span><span class="c14">Task </span><span class="c4">= </span><span class="c13">TGraphTask</span><span class="c4">&lt;</span><span class="c13">FMyTask</span><span class="c4">&gt;</span><span class="c3">::</span><span class="c0">CreateTask</span><span class="c4">(&amp;</span><span class="c14">PrerequisitesList</span><span class="c4">, </span><span class="c8">ENamedThreads</span><span class="c3">::</span><span class="c15">GameThread</span><span class="c4">).</span><span class="c0">ConstructAndDispatchWhenReady</span><span class="c6 c4">();</span></p><p class="c2"><span class="c6 c8"></span></p><p class="c16"><span class="c0">CreateTask</span><span class="c4">()</span><span>&nbsp;returns an </span><span class="c13">FConstructor</span><span>&nbsp;that </span><span class="c0">ConstructAndDispatchWhenReady</span><span class="c4">()</span><span>&nbsp;uses to make the </span><span class="c13">FMyTask</span><span>&nbsp;you provide it. </span><span class="c8">ENamedThreads</span><span>&nbsp;here is the thread the call is made from, not the one to run the Task on. &nbsp;</span></p><h4 class="c7" id="h.d8njiu9pgd68"><span class="c40">AsyncPool, AsyncThread, TFuture and TPromise</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>Some things in that engine are just purely undocumented, and </span><span class="c32">I doubt what follows was meant to be used directly as-is</span><span class="c6 c9">. </span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">AsyncPool</span><span class="c6 c9">&nbsp;seems to execute functions on a preprovided thread pool, and you can pass an optional callback function to execute when done:</span></p><p class="c5"><span class="c13">FQueuedThreadPool</span><span class="c4">* </span><span class="c14">Pool </span><span class="c4">= </span><span class="c13">FQueuedThreadPool</span><span class="c3">::</span><span class="c0">Allocate</span><span class="c4">(); </span><span class="c10">// Or Pool = GThreadPool;</span></p><p class="c5"><span class="c8">verify</span><span class="c4">(</span><span class="c14">Pool</span><span class="c4">-&gt;</span><span class="c0">Create</span><span class="c4">(</span><span class="c15">4</span><span class="c4">, </span><span class="c15">32 </span><span class="c4">* </span><span class="c15">1024</span><span class="c4">, </span><span class="c15">TPri_Normal</span><span class="c6 c4">));</span></p><p class="c1"><span class="c4 c21 c34"></span></p><p class="c5"><span class="c13">TUniqueFunction</span><span class="c4">&lt;</span><span class="c8">void</span><span class="c4">()&gt; </span><span class="c14">Callback</span><span class="c4">&nbsp;= []() { </span><span class="c10">// Wrap in MoveTemp() to pass as parameter</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10">/* Callback code */</span></p><p class="c5"><span class="c4">};</span></p><p class="c5"><span class="c13">TFunction</span><span class="c4">&lt;</span><span class="c8">void</span><span class="c4">()&gt; </span><span class="c14">Body </span><span class="c4">= []()</span><span class="c28">&nbsp;</span><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10 c21">/ Work on a thread pool */</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c5"><span class="c13">AsyncPool</span><span class="c4">(*</span><span class="c14">Pool</span><span class="c4">, </span><span class="c14">Body</span><span class="c4">, </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Callback</span><span class="c4">));</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The </span><span class="c13">FQueuedThreadPool</span><span class="c6 c9">&nbsp;seems to also be used with functions such as this:</span></p><p class="c5"><span class="c13">IQueuedWork</span><span class="c4">* </span><span class="c14">Work</span><span class="c4">; </span><span class="c14">Pool</span><span class="c4">-&gt;</span><span class="c0">AddQueuedWork</span><span class="c4">(</span><span class="c14">Work</span><span class="c4">);</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">AsyncThread</span><span>&nbsp;probably creates a new thread in the same vein as </span><span class="c13">FRunnable</span><span>, and can return a </span><span class="c13">TFuture</span><span class="c6 c9">&nbsp;struct when done:</span></p><p class="c5"><span class="c13">TFunction</span><span class="c4">&lt;</span><span class="c8">bool</span><span class="c4">()&gt; </span><span class="c14">Task </span><span class="c4">= []()</span><span class="c28">&nbsp;</span><span class="c6 c4">{</span></p><p class="c5"><span class="c10">&nbsp; /* Work on a new thread */</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return true</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c5"><span class="c13">TFuture</span><span class="c4">&lt;</span><span class="c8">bool</span><span class="c4">&gt; </span><span class="c14">FutureResult </span><span class="c4">= </span><span class="c13">AsyncThread</span><span class="c4">(</span><span class="c14">Task</span><span class="c4">);</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>As to how </span><span class="c13">TFuture</span><span>&nbsp;and </span><span class="c13">TPromise</span><span>&nbsp;are meant to be used, well, I don&rsquo;t know either. Seems to be a system of callbacks, with functions like </span><span class="c14">Future</span><span class="c4">.</span><span class="c0">IsReady</span><span class="c4">()</span><span>, </span><span class="c14">Future</span><span class="c4">.</span><span class="c0">IsValid</span><span class="c4">()</span><span>&nbsp;and </span><span class="c14">Future </span><span class="c4">= </span><span class="c14">Promise</span><span class="c4">.</span><span class="c0">GetFuture</span><span class="c4">()</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Some more info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://jdelezenne.github.io/Codex/UE4/Multithreading.html&amp;sa=D&amp;source=editors&amp;ust=1712085893378918&amp;usg=AOvVaw1wTR2RUNnYKwD-UKnAXTPK">here</a></span><span>&nbsp;and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/donaldwuid/unreal_source_explained/blob/master/main/thread.md&amp;sa=D&amp;source=editors&amp;ust=1712085893379078&amp;usg=AOvVaw2PEQdEdUymE-7yV-yFwXud">here</a></span><span>.</span></p><h3 class="c29" id="h.ul6rg4622sug"><span class="c20 c46">3. </span><span>Communicating </span><span class="c46 c20">with your Thread</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>Beware that modifying </span><span class="c13">UObjects</span><span>&nbsp;and </span><span class="c13">AActors</span><span class="c6 c9">&nbsp;from a thread may not be supported, due to the way Unreal and its Garbage Collector is setup. Prefer doing your computations in async, and apply the results back onto the main thread.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The following assumes you are using </span><span class="c13">FRunnable</span><span class="c6 c9">&nbsp;as your threading structure, but the other approaches behave similarly.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">When starting the thread, you can pass any list of parameters, by copy, pointer or reference through the Constructor:</span></p><p class="c5"><span class="c0">FMyThread</span><span class="c4">(</span><span class="c8">int </span><span class="c14">_i</span><span class="c4">, </span><span class="c13">AMyActor</span><span class="c4">* </span><span class="c14">_Actor</span><span class="c4">, </span><span class="c8">FVector</span><span class="c4">&amp; </span><span class="c14">_Vector</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c11">i </span><span class="c4">=</span><span class="c14">&nbsp;_i</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c11">Actor </span><span class="c4">=</span><span class="c14">&nbsp;A_Actor</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">&nbsp; FVector</span><span class="c4">&amp; </span><span class="c14">Vector</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">_Vector</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Using an</span><span class="c25">&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/utility/initializer_list&amp;sa=D&amp;source=editors&amp;ust=1712085893381450&amp;usg=AOvVaw17KgQ9E6vhvzIqiZk9h_AO">initializer list</a></span><span class="c6 c9">, you can even initialize member references, and make the formatting snappier while reusing names:</span></p><p class="c5"><span class="c0">FMyThread</span><span class="c4">(</span><span class="c8">int </span><span class="c14">i</span><span class="c4">, </span><span class="c13">AMyActor</span><span class="c4">* </span><span class="c14">Actor</span><span class="c4">, </span><span class="c8">FVector</span><span class="c4">&amp; </span><span class="c14">Vector</span><span class="c4">) </span><span class="c3">: </span><span class="c11">i</span><span class="c4">{</span><span class="c14">i</span><span class="c4">},</span><span class="c3">&nbsp;</span><span class="c11">Actor</span><span class="c4">{</span><span class="c14">Actor</span><span class="c4">},</span><span class="c3">&nbsp;</span><span class="c11">Vector</span><span class="c4">{</span><span class="c14">Vector</span><span class="c4">}</span><span class="c10">&nbsp;</span><span class="c6 c4">{}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">FVector</span><span class="c4">&amp; </span><span class="c11">Vector</span><span class="c4">; </span><span class="c10">// Member reference, cannot be initialized by other means than the above</span></p><h4 class="c7" id="h.nsitajrh3htx"><span class="c36 c20">How shared memory is managed</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">It is actually possible to read or modify variables and call functions from anywhere in or outside your thread.</span></p><p class="c5"><span class="c13">uint32 FMyThread</span><span class="c3">::</span><span class="c0">Run</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c11">&nbsp; Actor</span><span class="c4">-&gt;</span><span class="c11">bIsBeingThreaded </span><span class="c4">= </span><span class="c8">true</span><span class="c4">; </span><span class="c10">// Variable from another class</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">while </span><span class="c4">(!</span><span class="c11">bShutdown</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c11">Actor</span><span class="c4">-&gt;</span><span class="c0">DoThreadedWork</span><span class="c4">(); </span><span class="c10">// Function from another class</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The only important limitation to this is concurrent writing: while reading a variable is threadsafe, having multiple threads write into one can lead to</span><span class="c25">&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.modernescpp.com/index.php/race-condition-versus-data-race&amp;sa=D&amp;source=editors&amp;ust=1712085893384496&amp;usg=AOvVaw05laqfEvodd8pdHIGX0lmC">data races</a></span><span class="c6 c9">, or in the case of operations that resize containers such as TArray adds, invalidating all pointers to that array, which is an EXCEPTION_ACCESS_VIOLATION waiting to happen.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">There are multiple approaches to counter this:</span></p><p class="c16"><span class="c6 c9">- Maximize the amount of local variables in your threaded functions, and prefer sending your parameters through the constructor by copy. This can however become very expensive when copying large arrays of elements.</span></p><p class="c16"><span>- While one thread runs operations on a container, on the others avoid all operations that may trigger a memory reallocation, such as </span><span class="c0">Add</span><span class="c4">()</span><span>, </span><span class="c0">Remove</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">SetNum</span><span class="c4">()</span><span class="c6 c9">. Writing to TArray/TMap indices while reading into others with concurrent threads is actually feasible, as long as the operations are not on the same indices, and do not add or remove elements.</span></p><p class="c16"><span class="c6 c9">- Use &ldquo;FlipFlop&rdquo; containers, such that each thread locks access to one while performing its work, and releases it for others to use when done.</span></p><p class="c16"><span class="c6 c9">- Use Move Semantics; more about that later down.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">C++11 and Unreal also provide multiple threadsafe tools:</span></p><h6 class="c23" id="h.dytdkm4loqcr"><span class="c24 c20">thread_local</span></h6><p class="c16"><span>If you are running multiple threads within the same class, you may want to preface your member variables with</span><span class="c25">&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/11983875/what-does-the-thread-local-mean-in-c11&amp;sa=D&amp;source=editors&amp;ust=1712085893385910&amp;usg=AOvVaw22Vdnaxg4EqKsXGUUh_Sws">thread_local</a></span><span class="c6 c9">. This will guarantee that each thread receives its own individual instances of the variables.</span></p><h6 class="c23" id="h.5p06pceyrcy2"><span class="c24 c20">std::atomic</span></h6><p class="c16"><span>By wrapping a variable in an </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/31978324/what-exactly-is-stdatomic&amp;sa=D&amp;source=editors&amp;ust=1712085893386296&amp;usg=AOvVaw2iq46YEKQLgJZO9QXylUV0">atomic</a></span><span>, such as </span><span class="c8">std</span><span class="c3">::</span><span class="c8">atomic</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c11">i</span><span class="c4">;</span><span class="c6 c9">, you ensure that reads and writes to it are always threadsafe, and you can also define how concurrent writes are synchronized, though the syntax may be more complex (see link). Atomics can come at a substantial performance cost due to the added synchronization load, so try to use them only when inter-thread communication is necessary.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>An std::atomic can only wrap relatively simple types such as ints and bools; it will not compile around containers like </span><span class="c13">TArray</span><span>. A </span><span class="c8">struct</span><span>&nbsp;can be made atomic, but this will only make assigning the whole struct threadsafe, not modifying individual members inside it (</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/50601726/is-it-ok-to-use-stdatomic-with-a-struct-that-is-pod-except-that-it-has-a-const&amp;sa=D&amp;source=editors&amp;ust=1712085893387056&amp;usg=AOvVaw3vXdJVlmc88kMWT9uX_y8C">more info</a></span><span>). The linked page provides an alternative of deriving a struct from </span><span class="c8">std</span><span class="c3">::</span><span class="c13">mutex</span><span>&nbsp;</span><span>(same with </span><span class="c13">FCriticalSection</span><span>),</span><span>&nbsp;and use </span><span class="c14">Struct</span><span class="c4">.</span><span class="c0">Lock</span><span class="c4">()</span><span>&nbsp;before accessing</span><span class="c6 c9">&nbsp;members for thread safety.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Use std::atomics, as Unreal&rsquo;s TAtomics are considered deprecated.</span></p><h6 class="c23" id="h.fj003z4faj8a"><span class="c20">FPlatformAtomics</span></h6><p class="c16"><span class="c26 c44">Using operations such as </span><span class="c13 c26">FPlatformAtomics</span><span class="c3 c26">::</span><span class="c0 c26">InterlockedAdd</span><span class="c4 c26">(&amp;</span><span class="c11">i</span><span class="c4 c26">, </span><span class="c15 c26">10</span><span class="c4 c26">)</span><span class="c26 c44">, you can perform atomic operations directly without having to declare either the variable itself as atomic, or using </span><span class="c13 c26">FCriticalSection</span><span class="c26 c44">. Includes modifying (Read, Add, Store, Increment, Decrement), logical comparisons (And, Or), etc. Some default classes implement those, such as </span><span class="c13 c26">FThreadSafeBool</span><span class="c26 c44">&nbsp;and </span><span class="c13 c26">FThreadSafeCounter</span><span class="c6 c9">.</span></p><h6 class="c23" id="h.lc84iht7j2j"><span class="c20">TQueue</span><span>s</span></h6><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/TQueue/&amp;sa=D&amp;source=editors&amp;ust=1712085893388771&amp;usg=AOvVaw3Rw1HA7pHQoiURAr8xxlwZ">TQueue</a></span><span class="c25">&nbsp;</span><span>allows for threadsafe atomic concurrent writing into a single container, with the usual setup being one or multiple threads (depending on the </span><span class="c13">EQueueMode</span><span>) adding elements, while a single other pops the results. You can even queue other containers, such as </span><span class="c13">TQueue</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt;</span><span>.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>As it is a FIFO queue, elements get added to the start with </span><span class="c0">Enqueue</span><span class="c4">()</span><span>, and removed at the end with </span><span class="c0">Dequeue</span><span class="c4">()</span><span>. The container is a </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://jbseg.medium.com/lock-free-queues-e48de693654b&amp;sa=D&amp;source=editors&amp;ust=1712085893389501&amp;usg=AOvVaw1DnVyElXXnWd5VkDpsFpZ2">lock-free</a></span><span>&nbsp;list</span><span>, which avoids the usual performance overhead of mutexes around container accesses, and is </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/1970345/what-is-thread-contention&amp;sa=D&amp;source=editors&amp;ust=1712085893389678&amp;usg=AOvVaw1RrkfhzF9jyFRCqdyLveTV">contention</a></span><span class="c6 c9">-free in Single-producer mode (SPSC), but not in Multi-producer (MPSC).</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TCircularQueue/&amp;sa=D&amp;source=editors&amp;ust=1712085893389971&amp;usg=AOvVaw0N4c7VwLBSvb69kkmgLsIs">TCircularQueue</a></span><span>&nbsp;is a variant based on </span><span class="c13">TCircularBuffer</span><span>, also lock-free and FIFO but only supporting SPSC and with a static capacity (rounded to a power of 2, minus 1). Some </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://forums.unrealengine.com/t/how-to-use-tcircularqueue/404742&amp;sa=D&amp;source=editors&amp;ust=1712085893390168&amp;usg=AOvVaw3dQuAP_HHZeq3e5s7V7m9U">examples</a></span><span class="c6 c9">.</span></p><p class="c5"><span class="c8">#include </span><span class="c39">&quot;Containers/CircularQueue.h&quot;</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">c</span><span class="c8">lass </span><span class="c13">FMyClass </span><span class="c3">: </span><span class="c8">public </span><span class="c13">FRunnable </span><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c0">FMyClass</span><span class="c4">(</span><span class="c13">uint32 </span><span class="c14">QueueSize</span><span class="c4">) </span><span class="c3">: </span><span class="c11">Queue</span><span class="c4">{</span><span class="c14">QueueSize</span><span class="c4">} { </span><span class="c10">// Capacity initialized from list</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c13">TCircularQueue</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">QueueB</span><span class="c4">(</span><span class="c14">QueueSize</span><span class="c4">); </span><span class="c10">// Capacity initiliazed from a constructor</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c13">TCircularQueue</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c11">Queue</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>There&rsquo;s one last, undocumented class deeply hidden in the source files called </span><span class="c13">TSafeQueue</span><span class="c6 c9">, a FIFO Multi-producer Multi-consumer queue with minimal locks.</span></p><p class="c5"><span class="c8">#include </span><span class="c6 c39">&quot;UnrealAudio/Private/UnrealAudioUtilities.h&quot;</span></p><p class="c5"><span class="c8">using namespace UAudio</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c13">TSafeQueue</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c11">Queue</span><span class="c4">;</span></p><h6 class="c23" id="h.kwtqvjj4svzk"><span class="c24 c20">TLockFreePointerList and TListThreadSafe</span></h6><p class="c16"><span class="c13">TLockFreePointerList</span><span>&nbsp;is a container</span><span>&nbsp;like </span><span class="c13">TQueue</span><span>&nbsp;similarly based on a list, for threadsafe and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/ABA_problem&amp;sa=D&amp;source=editors&amp;ust=1712085893392927&amp;usg=AOvVaw1iStG8kAoztsjdtJ7BnHQB">ABA-resistant</a></span><span class="c6 c9">&nbsp;pointer storage. Can be either FIFO (first in, first out), LIFO (last in, first out) or unordered. Used inside the engine&rsquo;s TaskGraph.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c8">Chaos</span><span class="c3">::</span><span class="c13">TListThreadSafe</span><span>&nbsp;is a lock-free, single-linked list, that is read out by being extracted as a </span><span class="c13">TList</span><span>&nbsp;(a convoluted setup; see the section on </span><span class="c13">TList</span><span class="c6 c9">&nbsp;for how this is done). Seems to support Multi-producer Multi-consumer scenarios.</span></p><h6 class="c23" id="h.9za85jy0pxdr"><span class="c24 c20">FCriticalSection and FScopeLock</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://georgy.dev/posts/mutex/&amp;sa=D&amp;source=editors&amp;ust=1712085893393661&amp;usg=AOvVaw28lGgsW-R9-DlQr1EyZL4g">FCriticalSection</a></span><span class="c25">&nbsp;</span><span>(Unreal&rsquo;s implementation of </span><span class="c8">std</span><span class="c3">::</span><span class="c13">mutex</span><span class="c6 c9">), prevents race conditions by locking all threads until the current one has exited the section. This is fast until two threads enter the same lock concurrently, which triggers it and pauses all but one (contention). Deadlocks can also occur when using multiple mutexes, if different threads grab a lock required for another to proceed.</span></p><p class="c5"><span class="c13">FCriticalSection </span><span class="c11">Section</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">uint32 FMyThread</span><span class="c3">::</span><span class="c0">Run</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c11">&nbsp; Section</span><span class="c4">.</span><span class="c0">Lock</span><span class="c6 c4">();</span></p><p class="c5"><span class="c10">&nbsp; /* Threadsafe section */</span></p><p class="c5"><span class="c11">&nbsp; Section</span><span class="c4">.</span><span class="c0">Unlock</span><span class="c4">();</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">FScopeLock</span><span class="c6 c9">&nbsp;will perform the same operation, except it will unlock by itself once the scope has been exited (i.e. the brace closes).</span></p><p class="c5"><span class="c13">FCriticalSection </span><span class="c11">Section</span><span class="c4">;</span></p><p class="c1"><span class="c6 c13"></span></p><p class="c5"><span class="c13">uint32 FMyThread</span><span class="c3">::</span><span class="c0">Run</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c6 c4">&nbsp; {</span></p><p class="c5"><span class="c13">&nbsp; &nbsp; FScopeLock </span><span class="c14">Lock</span><span class="c4">(&amp;</span><span class="c11">Section</span><span class="c6 c4">);</span></p><p class="c5"><span class="c10">&nbsp; &nbsp; /* Threadsafe until the closing brace */</span></p><p class="c5"><span class="c4">&nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">FScopeLock is safer to handle due to automatically releasing the lock, but FCriticalSection is also useful in being able to wrap tightly around the parts requiring threadsafe access.</span></p><h6 class="c23" id="h.f28e9qd435yz"><span class="c24 c20">FSpinLock (UE5)</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Misc/FSpinLock/&amp;sa=D&amp;source=editors&amp;ust=1712085893396704&amp;usg=AOvVaw3F2TIs79te4I5itEPdqz9K">FSpinLock</a></span><span>&nbsp;is a variant of FCriticalSection that repeatedly tries to acquire the lock instead of putting the thread to sleep. Useful only in the specific circumstance where your lock covers little code, and it is faster to wait by keeping the CPU busy rather than sleeping.</span></p><h6 class="c23" id="h.is1ir5o0zgz"><span class="c24 c20">TSharedPtr</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Templates/TSharedPtr/&amp;sa=D&amp;source=editors&amp;ust=1712085893397110&amp;usg=AOvVaw3TkBF-yb7VfF_7q7U37-hB">TSharedPtr</a></span><span class="c25">&nbsp;</span><span>provides a mode for threadsafe atomic operations. This (as is general with atomics), comes with a performance impact.</span></p><h4 class="c7" id="h.68or2sz6e61n"><span class="c38 c20">Callbacks from threads</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>If you plan on doing more useful operations than calculating the first 50,000 prime numbers, you&rsquo;ll probably want the game thread to be notified or run events when your thread has finished your calculations; but you might also have noticed there&rsquo;s no straightforward method provided by the aforementioned classes (FRunnable&rsquo;s </span><span class="c0">Run</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">Exit</span><span class="c4">()</span><span class="c6 c9">&nbsp;both run in the new thread, and there are no &ldquo;post-execution&rdquo; functions in game thread).</span></p><h6 class="c23" id="h.bdv1ltf9cw05"><span class="c24 c20">Direct</span></h6><p class="c16"><span>The first and simplest method is as basic as calling a function of your choice, from within or outside your thread class.</span></p><p class="c5"><span class="c13">uint32 FMyThread</span><span class="c3">::</span><span class="c0">Run</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c10 c21">&nbsp; /* Threaded code */</span></p><p class="c5"><span class="c11">&nbsp; Actor</span><span class="c4">-&gt;</span><span class="c0">ThreadCallback</span><span class="c6 c4">();</span></p><p class="c5"><span class="c11">&nbsp; Actor</span><span class="c4">-&gt;</span><span class="c11">bIsBeingThreaded </span><span class="c4">= </span><span class="c8">false</span><span class="c4">; </span><span class="c10">// Preferably atomic</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>There is no technical limitation against that, with the one </span><span class="c34">big</span><span>&nbsp;caveat that since</span><span class="c6 c9">&nbsp;you are doing it from within a threaded function, this will also run inside the same thread. Avoid therefore calling directly code you did not intend to run threaded, and prefer writing into variables or containers (safer when atomic) what information you need to transmit, so that other game thread functions may read it back on their next EventTick.</span></p><h6 class="c23" id="h.rn5j3bp8opju"><span class="c24 c20">Async</span></h6><p class="c16"><span>Alternatively, you can wrap that call into an </span><span class="c13">AsyncTask</span><span class="c6 c9">&nbsp;running in the game thread. This avoids most of the aforementioned issues.</span></p><p class="c5"><span class="c13">AsyncTask</span><span class="c4">(</span><span class="c8">ENamedThreads</span><span class="c3">::</span><span class="c15">GameThread</span><span class="c4">, [</span><span class="c8">this</span><span class="c4">, </span><span class="c14">Vector</span><span class="c4">] () {</span></p><p class="c5"><span class="c11 c34">&nbsp; </span><span class="c11">Actor</span><span class="c4">-&gt;</span><span class="c0">ThreadCallback</span><span class="c4">(</span><span class="c14">Vector</span><span class="c4">);</span></p><p class="c5"><span class="c4">});</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Using AsyncTasks to repeatedly send very short messages can be somewhat inefficient</span><span>, so avoid this approach if you expect to make callbacks 1000 times a second, and where a &ldquo;direct&rdquo; call writing into atomics would suffice.</span></p><h6 class="c23" id="h.jiw9ocpcvuzh"><span class="c20">Delegates</span></h6><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://jdelezenne.github.io/Codex/UE4/Delegates%2520and%2520Lambas.html&amp;sa=D&amp;source=editors&amp;ust=1712085893400810&amp;usg=AOvVaw0xGwb9cd3zWixtfDteaANp">Delegate</a></span><span class="c25">&nbsp;</span><span>is as its core a function pointer: calling it calls the function it is bound to, you can pass parameters, have a return value, etc. They can be Multicast (call multiple functions at once), Dynamic (serializable and blueprint-friendly, but slower), </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/FSparseDelegateStorage/&amp;sa=D&amp;source=editors&amp;ust=1712085893401040&amp;usg=AOvVaw1vIU5fLaQVUBIVm_GA3Ijr">Sparse</a></span><span class="c25">&nbsp;</span><span>(lower memory usage if not bound), </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/Events/&amp;sa=D&amp;source=editors&amp;ust=1712085893401256&amp;usg=AOvVaw0l1s6q7A0vpLqYCdR_0KeN">Events</a></span><span>&nbsp;(only the declaring class can call it); be bound with UFunctions, UObjects, shared pointers, lambdas... More info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://conoscerelinux.org/wp-content/uploads/2019/11/Mischitelli-Slides-Nov2019.pdf&amp;sa=D&amp;source=editors&amp;ust=1712085893401437&amp;usg=AOvVaw1NTAwUdgtVYRmY7ZT26eiZ">there</a></span><span class="c25">&nbsp;</span><span>and</span><span>&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.0/en-US/delegates-and-lamba-functions-in-unreal-engine/&amp;sa=D&amp;source=editors&amp;ust=1712085893401646&amp;usg=AOvVaw1tq50UcoEtM0RRSbEre3TO">there</a></span><span>.</span></p><p class="c5"><span class="c10">// Declaring a Singlecast, one-parameter void Delegate (done before classes)</span></p><p class="c5"><span class="c8">DECLARE_DELEGATE_OneParam</span><span class="c4">(</span><span class="c13">FMyDelegate</span><span class="c4">, </span><span class="c8">FVector </span><span class="c10">/*, ParameterName (optional) */ </span><span class="c4">)</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c10">// Create, bind and execute (use .AddUFunction() and .Broadcast() if Multicast)</span></p><p class="c5"><span class="c13">FMyDelegate </span><span class="c11">Delegate</span><span class="c4">;</span></p><p class="c5"><span class="c11">Delegate</span><span class="c4">.</span><span class="c0">BindUFunction</span><span class="c4">(</span><span class="c8">this</span><span class="c4">, </span><span class="c13">FName</span><span class="c4">(</span><span class="c39">&quot;MyFunction&quot;</span><span class="c4">)); </span><span class="c10">// &quot;this&quot; can be replaced by any class</span></p><p class="c5"><span class="c11">Delegate</span><span class="c4">.</span><span class="c0">ExecuteIfBound</span><span class="c4">(</span><span class="c8">FVector</span><span class="c4">(</span><span class="c14">Vector</span><span class="c4">));</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>When you execute/broadcast, &lsquo;listeners&rsquo; to that delegate will run like normal functions in the thread they are called from; wrap in an </span><span class="c13">AsyncTask</span><span>&nbsp;if you want to avoid that.</span></p><h6 class="c23" id="h.s3lxk4cc6ld0"><span class="c24 c20">Lambdas</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://benui.ca/unreal/tfunctionref/&amp;sa=D&amp;source=editors&amp;ust=1712085893403810&amp;usg=AOvVaw0yvhk1AqwO_t1qA6tS-kAf">TFunctions</a></span><span class="c25">&nbsp;</span><span>(i.e. </span><span>lambdas</span><span>)</span><span class="c42">&nbsp;</span><span class="c6 c9">allow you to pass a function anonymously, which is useful for example to avoid circular dependencies in your code.</span></p><p class="c5"><span class="c10 c21">/* Passing a function returning a vector anonymously through a TFunctionRef in the constructor */</span></p><p class="c5"><span class="c10">// Caller</span></p><p class="c5"><span class="c13">TFunctionRef</span><span class="c4">&lt;</span><span class="c8">void </span><span class="c4">(</span><span class="c8">FVector</span><span class="c4">)&gt; </span><span class="c14">Callback </span><span class="c4">= [&amp;](</span><span class="c8">FVector </span><span class="c14">Vector</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c0">ThreadCallback</span><span class="c4">(</span><span class="c14">Vector</span><span class="c4">); </span><span class="c10">// What the lambda will execute when called</span></p><p class="c5"><span class="c4">};</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">Thread </span><span class="c3">= </span><span class="c8">new </span><span class="c0">FMyThread</span><span class="c4">( </span><span class="c10">/*Parameters, */ </span><span class="c14">Callback</span><span class="c10">&nbsp;</span><span class="c4">);</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c10">// MyThread .h</span></p><p class="c5"><span class="c0">FMyThread</span><span class="c4">( </span><span class="c10">/*Parameters, */ </span><span class="c13">TFunctionRef</span><span class="c4">&lt;</span><span class="c8">void </span><span class="c4">(</span><span class="c8">FVector</span><span class="c4">)&gt; </span><span class="c14">Callback</span><span class="c4">) </span><span class="c3">:</span><span class="c3">&nbsp;</span><span class="c11">Callback</span><span class="c4">{</span><span class="c14">Callback</span><span class="c6 c4">} {}</span></p><p class="c1"><span class="c6 c13"></span></p><p class="c5"><span class="c13">TFunctionRef</span><span class="c4">&lt;</span><span class="c8">void </span><span class="c4">(</span><span class="c8">FVector</span><span class="c4">)&gt;&amp; </span><span class="c11">Callback</span><span class="c4">; </span><span class="c10">// Can be called like a normal function</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>B</span><span>eware that they will also run in the same thread they are called from. </span><span class="c13">TFunction</span><span>&nbsp;will store a copy of the function, while </span><span class="c13">TFunctionRef</span><span>&nbsp;will avoid the copy cost by instead using a reference, and </span><span class="c13">TUniqueFunction</span><span>&nbsp;is moved in its entirety using </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://jdelezenne.github.io/Codex/UE4/Delegates%2520and%2520Lambas.html&amp;sa=D&amp;source=editors&amp;ust=1712085893407182&amp;usg=AOvVaw3fdm4Y7xm0O3uRvQeQDBnW">More info</a></span><span>.</span></p><h4 class="c7" id="h.qxfgxthtj6rp"><span>Stopping, syncing and resuming threads</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">While it is possible to start a new thread for every discrete operation you may need calculations for, this is an expensive operation that also slows the game thread down when repeated. Prefer sending work in larger packages, or keeping the thread alive continuously by putting it to sleep until another call asks it to resume work.</span></p><h6 class="c23" id="h.pvttmpondkx6"><span class="c24 c20">Stopping</span></h6><p class="c16"><span class="c0">WaitForCompletion</span><span class="c4">()</span><span>&nbsp;ensures an </span><span class="c13">FRunnable</span><span class="c6 c9">&nbsp;has stopped before continuing execution, by stalling the caller until the thread has completed:</span></p><p class="c5"><span class="c0">~AMyClass</span><span class="c4">() { </span><span class="c10">// Put in the destructor of holder class for orderly destruction</span></p><p class="c5"><span class="c11">&nbsp; Thread</span><span class="c4">-&gt;</span><span class="c0">Kill</span><span class="c4">(); </span><span class="c10">// Calls your implementation of Exit()</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c11">Thread</span><span class="c4">-&gt;</span><span class="c0">WaitForCompletion</span><span class="c4">(); </span><span class="c10">// Stalls the caller until completion</span></p><p class="c5"><span class="c8">&nbsp; delete </span><span class="c11">Thread</span><span class="c6 c4">;</span></p><p class="c5"><span class="c14">&nbsp; </span><span class="c11">Thread </span><span class="c4">= </span><span class="c8">nullptr</span><span class="c4">;</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This is needed even after calling </span><span class="c0">Kill</span><span class="c4">()</span><span class="c6 c9">&nbsp;when deleting actors, as some of the thread&rsquo;s internal logic may still be running for one or two frames and deleting references too early would crash.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Implement this in the destructor of any class the thread references to be able to safely destroy them. This also prevents the editor from crashing every time you exit Play In Editor while a thread runs.</span></p><h6 class="c23" id="h.e2dsel997ub5"><span class="c24 c20">Pausing</span></h6><p class="c16"><span>Somewhat similarly to blueprints&rsquo; delay node, </span><span class="c0">Sleep</span><span class="c4">()</span><span>&nbsp;puts the thread it is called in to sleep without consuming resources. You might prefer not calling it from within the game thread if you do not intend to create a freezing simulator. </span></p><p class="c5"><span class="c13">FPlatformProcess</span><span class="c3">::</span><span class="c0">Sleep</span><span class="c4">(</span><span class="c15">0.01f</span><span class="c4">); </span><span class="c10">// Time in seconds</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Example usage is to check at regular intervals if a boolean asking to resume has been set to true, else continue sleeping.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c0">ConditionalSleep</span><span class="c4">()</span><span class="c6 c9">&nbsp;allows defining directly the condition to check for, through a lambda:</span></p><p class="c5"><span class="c8">bool </span><span class="c11">bResume</span><span class="c4">;</span></p><p class="c1"><span class="c6 c13"></span></p><p class="c5"><span class="c13">FPlatformProcess</span><span class="c3">::</span><span class="c0">ConditionalSleep</span><span class="c4">([</span><span class="c8">this</span><span class="c4">]() -&gt; </span><span class="c8">bool </span><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c11">bResume</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">});</span></p><p class="c2"><span class="c6 c13"></span></p><p class="c16"><span class="c13">FRunnable</span><span>&nbsp;also provides a </span><span class="c0">Suspend</span><span class="c4">()</span><span>&nbsp;function, which seems to be only effective when the platform doesn&rsquo;t support multithreading and instead implements </span><span class="c13">FFakeThread</span><span>&nbsp;or </span><span class="c13">FSingleThreadRunnable</span><span>, through disabling the </span><span class="c0">Tick</span><span class="c4">()</span><span class="c6 c9">&nbsp;on that &lsquo;thread&rsquo;.</span></p><p class="c5"><span class="c11">Thread</span><span class="c4">-&gt;</span><span class="c0">Suspend</span><span class="c4">(</span><span class="c8">true</span><span class="c4">); </span><span class="c10">// Suspends or resumes depending on the passed value</span></p><h6 class="c23" id="h.gmgzp28d2iet"><span class="c24 c20">FScopedEvent and FEvent</span></h6><p class="c16"><span>Once declared, an </span><span class="c13">FScopedEvent</span><span>&nbsp;will sleep the thread when the scope exits; you can then pass its pointer with </span><span class="c14">Event</span><span class="c4">.</span><span class="c0">Get</span><span class="c4">()</span><span>&nbsp;to another thread and call </span><span class="c14">Event</span><span class="c4">.</span><span class="c0">Trigger</span><span class="c4">()</span><span>&nbsp;inside it to resume execution.</span></p><p class="c5"><span class="c6 c4">{</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c13">FScopedEvent </span><span class="c14">Event</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c0">DoThreadedWork</span><span class="c4">(</span><span class="c14">Event</span><span class="c4">.</span><span class="c0">Get</span><span class="c6 c4">());</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c10 c21">/* Sleep at the closing brace until the other thread calls Event.Trigger(); */</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">FEvent</span><span>&nbsp;similarly uses </span><span class="c14">Event</span><span class="c4">-&gt;</span><span class="c0">Trigger</span><span class="c4">()</span><span>, but can be called at any time using </span><span class="c14">Event</span><span class="c4">-&gt;</span><span class="c0">Wait</span><span class="c4">()</span><span>. Since the class is abstract, you need to grab and return instances from a pool by pointer. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://michaeljcole.github.io/wiki.unrealengine.com/MultiThreading_and_synchronization_Guide/&amp;sa=D&amp;source=editors&amp;ust=1712085893414648&amp;usg=AOvVaw1Ff4juUZyW_5Z3bn5nU_kj">Example</a></span><span>.</span></p><p class="c5"><span class="c13">FEvent</span><span class="c4">* </span><span class="c11">Event</span><span class="c4">;</span></p><p class="c1"><span class="c6 c0"></span></p><p class="c5"><span class="c0">FMyClass</span><span class="c4">() { </span><span class="c10">// Constructor</span></p><p class="c5"><span class="c11">&nbsp; Event </span><span class="c4">= </span><span class="c8">FGenericPlatformProcess</span><span class="c3">::</span><span class="c0">GetSynchEventFromPool</span><span class="c4">(</span><span class="c8">false</span><span class="c6 c4">);</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c0">~FMyClass</span><span class="c4">() { </span><span class="c10">// Destructor</span></p><p class="c5"><span class="c8">&nbsp; FGenericPlatformProcess</span><span class="c3">::</span><span class="c0">ReturnSynchEventToPool</span><span class="c4">(</span><span class="c11">Event</span><span class="c6 c4">);</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c11">Event </span><span class="c4">= </span><span class="c8">nullptr</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Example usage is to force a worker thread to finish its work before the main thread can resume, or at the opposite end to sleep a worker thread until it is called again by the main thread. </span><span>Some sparse info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://conoscerelinux.org/wp-content/uploads/2019/11/Mischitelli-Slides-Nov2019.pdf&amp;sa=D&amp;source=editors&amp;ust=1712085893416672&amp;usg=AOvVaw2jHgvqkckw0DhHWxeXba5y">there</a></span><span>, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://de45xmedrsdbp.cloudfront.net/Resources/files/Multithreading-1112727176.pdf&amp;sa=D&amp;source=editors&amp;ust=1712085893416852&amp;usg=AOvVaw12KXvQtL2OYOJMOvnD8lpR">there</a></span><span>&nbsp;and</span><span class="c25">&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://artemis.ms.mff.cuni.cz/gemrot/lectures/gcg/2016/NPGR033-05-GameEngines-UE4.pdf&amp;sa=D&amp;source=editors&amp;ust=1712085893417040&amp;usg=AOvVaw3PfWdrVxuUur4JS8Llc9Ey">there</a></span><span>.</span></p><h1 class="c51" id="h.gi99uzvqmspj"><span class="c30">PERFORMANCE</span></h1><h3 class="c29" id="h.rrbgf1wdijci"><span class="c35">1. </span><span class="c35 c37">Containers</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">A major challenge with containers access lies between functions that take constant O(1), logarithmic O(Log n) or linear O(n) time to execute; with n being the amount of elements stored.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">The textbook example to avoid is:</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">auto</span><span class="c4">&amp; </span><span class="c14">n </span><span class="c3">: </span><span class="c11">ArrayA</span><span class="c4">) { </span><span class="c10">// For all n elements</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">if </span><span class="c4">(</span><span class="c14">ArrayB</span><span class="c4">.</span><span class="c0">Contains</span><span class="c4">(</span><span class="c14">n</span><span class="c4">)) </span><span class="c10">// Checks all n elements and stops at the first match</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c11">ArrayA</span><span class="c4">.</span><span class="c0">Remove</span><span class="c4">(</span><span class="c14">n</span><span class="c4">); </span><span class="c10">// Checks all n elements and remove if matching</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Where in a </span><span class="c34">for all n</span><span>&nbsp;loop, you&rsquo;ve nested an O(n) </span><span class="c0">Remove</span><span class="c4">()</span><span>&nbsp;and another up-to-O(n) </span><span class="c0">Contains</span><span class="c4">()</span><span>. This </span><span class="c34">will not</span><span>&nbsp;scale well with big </span><span class="c13">TArrays</span><span>. Using different approaches or switching container types is the way to go.</span></p><h4 class="c7" id="h.dq0zewgyf3os"><span class="c36 c35">Regular</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Those containers can be accessed or created directly in blueprints.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Be warned however that </span><span class="c8">UPROPERTY</span><span>&nbsp;big containers can sometimes cause performance issues in editor (especially with </span><span class="c8">EditAnywhere</span><span>), and in general I recommend doing A/B tests in Shipping too against such situations, as removing the </span><span class="c8">UPROPERTY</span><span>&nbsp;is an easy but somewhat obscure fix.</span></p><h6 class="c23" id="h.mzc5pvo3ron6"><span class="c24 c35">TArray</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/&amp;sa=D&amp;source=editors&amp;ust=1712085893420459&amp;usg=AOvVaw3vI1tpOVx2OTooucPRistK">TArrays</a></span><span class="c6 c9">&nbsp;are the bread and butter of most projects, but there are some things to watch out for:</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Operations such as </span><span class="c0">AddUnique</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">Remove</span><span class="c4">()</span><span>&nbsp;have to parse the entire array at every call to make sure there are no duplicates, which is a big performance hog. You can improve on this by using </span><span class="c0">RemoveSingle</span><span class="c4">()</span><span>&nbsp;(stops at the first find), or even </span><span class="c0">Add</span><span class="c4">()</span><span>&nbsp;and</span><span>&nbsp;</span><span class="c0">RemoveAt</span><span class="c4">()</span><span class="c6 c9">, which do not have to make expensive comparisons that scale poorly with many elements.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Using </span><span class="c0">RemoveSwap</span><span class="c4">()</span><span>, </span><span class="c0">RemoveAtSwap</span><span class="c4">()</span><span>&nbsp;or even </span><span class="c0">RemoveSingleSwap</span><span class="c4">()</span><span>, you can also avoid the overhead of the array reallocating when compacting gaps between elements, but this will not preserve the elements&rsquo; order; </span><span class="c0">RemoveAt</span><span class="c4">()</span><span>&nbsp;also has an optional </span><span class="c14">bAllowShrinking</span><span>&nbsp;bool you can disable</span><span>. A </span><span class="c13">TSet</span><span>&nbsp;is a better alternative if you don&rsquo;t need an ordered container, and </span><span class="c34">especially</span><span>&nbsp;if you make regular or nested </span><span class="c0">Contains</span><span class="c4">()</span><span>&nbsp;or </span><span class="c0">Remove</span><span class="c4">()</span><span class="c6 c9">&nbsp;calls.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c0">Add</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">Insert</span><span class="c4">()</span><span>&nbsp;create a copy of the passed value which is efficient for small types like </span><span class="c8">int</span><span>, while </span><span class="c0">Emplace</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">EmplaceAt</span><span class="c4">()</span><span>&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.geeksforgeeks.org/emplace-vs-insert-c-stl/&amp;sa=D&amp;source=editors&amp;ust=1712085893422571&amp;usg=AOvVaw1aSFTcvMTwLLBD-1hylpTN">construct a new instance</a></span><span>&nbsp;inside the container, which is better for types bigger than 64-bit as it avoids an expensive temporary copy. Technically, </span><span class="c0">Add</span><span class="c4">()</span><span>&nbsp;gets the value by reference, checks its validity and internally calls </span><span class="c0">Emplace</span><span class="c4">()</span><span>. Both still work through copy if you do not use </span><span class="c13">MoveTemp</span><span class="c4">()</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c0">AddUninitialized</span><span class="c4">()</span><span>, </span><span class="c0">InsertUninitialized</span><span class="c4">()</span><span>&nbsp;and</span><span>&nbsp;</span><span class="c0">SetNumUninitialized</span><span class="c4">()</span><span>&nbsp;(and their </span><span class="c0">Zeroed</span><span>&nbsp;equivalents) can also improve performance if you plan on overwriting the contents before doing any meaningful reads.</span></p><h6 class="c23" id="h.d6wvs6thv9jn"><span class="c24 c35">TSet</span></h6><p class="c16"><span>If you&rsquo;re fine with your container not being ordered, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TSet/&amp;sa=D&amp;source=editors&amp;ust=1712085893423764&amp;usg=AOvVaw2S3vM4gOlXSSgh8fw1mvVB">TSets</a></span><span>&nbsp;can be incredibly useful. They are multiple orders of magnitude faster (constant time) at </span><span class="c0">Add</span><span class="c4">()</span><span>, </span><span class="c0">Remove</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">Find</span><span class="c4">()</span><span>&nbsp;operations than a </span><span class="c13">TArray</span><span class="c6 c9">&nbsp;with many elements.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">This makes TSets very useful to store large amounts of unique items and make regular comparisons to other containers. For example, iterating through a TArray to see if an element is contained by a TSet is substantially faster than the reverse, or than comparing to another TArray. Sets are however less compact in memory than arrays.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>You can also enable duplicate elements using </span><span class="c8">DefaultKeyFuncs</span><span class="c6 c9">:</span></p><p class="c5"><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c8">FVector</span><span class="c4">, </span><span class="c8">DefaultKeyFuncs</span><span class="c4">&lt;</span><span class="c8">FVector</span><span class="c4">, </span><span class="c8">true</span><span class="c4">&gt;&gt; </span><span class="c11">MySet</span><span class="c4">;</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Note that both </span><span class="c11">MySet</span><span class="c4">[]</span><span>&nbsp;and </span><span class="c11">MySet</span><span class="c4">.</span><span class="c0">Find</span><span class="c4">()</span><span>&nbsp;work to access a key, but the latter returns a pointer that needs to be dereferenced to get the key, or </span><span class="c8">nullptr</span><span class="c6 c9">&nbsp;if the value is not in the set.</span></p><h6 class="c23" id="h.jxtovcxbnshm"><span class="c24 c35">TMap</span></h6><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/&amp;sa=D&amp;source=editors&amp;ust=1712085893425771&amp;usg=AOvVaw2w0WxFdHVoOXrJjyGNbQ2V">TMap</a></span><span>&nbsp;combines the features of a </span><span class="c13">TSet</span><span>&nbsp;(unordered, unique, constant time) with the ability to pair the key with a second element of any value. Doing </span><span class="c0">Add</span><span class="c4">()</span><span class="c6 c9">&nbsp;on a preexisting key will overwrite the contents of the second element with the provided value, or the default constructor if left empty.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>As one of the advantages of being unordered, removing keys leaves gaps in memory that will be filled again when others are added, reducing the amount of expensive resizings and reallocations of the whole container. </span></p><h4 class="c7" id="h.m1ddr7v8nbnt"><span class="c36 c35">C++ only</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>The following containers are not directly accessible through blueprints, but you can make your own </span><span class="c8">UFUNCTION</span><span>&nbsp;wrappers to rectify that.</span></p><h6 class="c23" id="h.vboamomyysqg"><span class="c24 c35">TStaticArray</span></h6><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TStaticArray/&amp;sa=D&amp;source=editors&amp;ust=1712085893426854&amp;usg=AOvVaw0FTEL4yaOOFyzD7F1avXAn">TStaticArray</a></span><span class="c6 c9">&nbsp;has its size predefined at compilation, which doesn&rsquo;t necessarily change much in terms of performance, but makes the intent clearer as to what it should and should not do. Pointers to it will also never become invalid due to reallocations.</span></p><p class="c5"><span class="c13">TStaticArray</span><span class="c4">&lt;</span><span class="c8">FVector</span><span class="c4">, </span><span class="c15">32</span><span class="c4">&gt; </span><span class="c11">MyArray</span><span class="c4">;</span></p><h6 class="c23" id="h.e84vobnes2cr"><span class="c35">TSparseArray</span></h6><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/TSparseArray/&amp;sa=D&amp;source=editors&amp;ust=1712085893427576&amp;usg=AOvVaw1XQj6VYO9MtXET-1bgjKRo">TSparseArray</a></span><span>&nbsp;couples a</span><span>&nbsp;</span><span class="c13">TArray</span><span>&nbsp;with an internal </span><span class="c13">TBitArray</span><span class="c6 c9">&nbsp;of bools to store which indices are allocated. </span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>It is unordered as added elements get assigned the first vacant index, and memory usage is similar as it still allocates space for all potential elements in a contiguous index range. Adding and removing is very fast (constant time) as the non-contiguous indices allow gaps to appear and fill again later without shuffling elements, and iteration is fast thanks to the </span><span class="c13">TBitArray</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Since </span><span class="c13">TSet</span><span>&nbsp;encapsulates a </span><span class="c13">TSparseArray</span><span class="c6 c9">&nbsp;in a hashing system that also allows constant time finding of elements, you might only prefer a sparse array if you&rsquo;re overly concerned with the added memory usage and don&rsquo;t need fast finds.</span></p><h6 class="c23" id="h.y3h0iz7fj1t4"><span class="c24 c35">TIndirectArray</span></h6><p class="c16"><span>In a regular </span><span class="c13">TArray</span><span>&nbsp;(equivalent to </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span class="c4">&lt;</span><span class="c8">Type</span><span class="c4">&gt;</span><span>), all instances of </span><span class="c8">Type</span><span>&nbsp;are stored directly into the container, and have to be reconstructed when the array grows or its elements shuffle around. This is efficient if the </span><span class="c8">sizeof</span><span class="c4">(</span><span class="c8">Type</span><span class="c4">)</span><span>&nbsp;</span><span>is small like </span><span class="c8">int</span><span class="c6 c9">&nbsp;(4~8 bytes), but becomes an issue with bigger objects, structs or nested containers.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">TIndirectArray</span><span>&nbsp;(equivalent to </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span class="c4">&lt;</span><span class="c8">Type</span><span class="c4">*&gt;</span><span class="c6 c9">) alleviates that by storing pointers to its elements instead of the elements themselves. When the elements are shuffled or reallocated, only pointers to them (8 bytes) have to be moved around instead of the actual elements.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Indirect arrays are very often used in source files to hold another dynamic container, a </span><span class="c8">struct</span><span>&nbsp;containing multiple dynamic containers or an </span><span class="c13">FString</span><span>&nbsp;(which is a </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TCHAR</span><span class="c4">&gt;</span><span>); this is because of the size of the objects owning the containers (an </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span>&nbsp;is a compile-constant 24 bytes, containing start and end pointers to the allocated memory and some metadata), but this is relevant to any object with a large </span><span class="c8">sizeof</span><span class="c4">()</span><span>. Doing this to store </span><span class="c8">ints</span><span>&nbsp;would be wasted; reallocations would not perform better as they are smaller or of similar size to pointers, this would take additional memory to store the pointers, and the added dereferencing for access also impacts performance. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://frogatto.com/2009/11/17/how-cs-vector-works-the-gritty-details/&amp;sa=D&amp;source=editors&amp;ust=1712085893430142&amp;usg=AOvVaw2fOepd6295fjPaW1_UPky1">More info</a></span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This is a less relevant concern for </span><span class="c13">TSet</span><span>&nbsp;and </span><span class="c13">TMap</span><span class="c6 c9">, as they are unordered and do not have to shuffle elements nearly as often.</span></p><h6 class="c23" id="h.1mzkky9eloye"><span class="c35">TChunkedArray</span></h6><p class="c16"><span>A </span><span class="c13">TChunkedArray</span><span>&nbsp;stores its elements in discrete chunks of memory (themselves of </span><span class="c13">TIndirectArray</span><span>&nbsp;type), so that adding new elements creates new chunks but never reallocates old ones. Useful if you want to keep on piling large types without repeatedly reallocating a progressively larger array, are concerned about allocation failures from memory fragmentation or if you&rsquo;d like to keep pointers valid. Some </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://rassadin.net/unreal-array-reallocation/&amp;sa=D&amp;source=editors&amp;ust=1712085893430903&amp;usg=AOvVaw1KSUD6ScPAEZOWBFLznLIh">more info</a></span><span>.</span></p><h6 class="c23" id="h.s5ldd21ustsx"><span class="c24 c35">TMultiMap and TSortedMap</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TMultiMap/&amp;sa=D&amp;source=editors&amp;ust=1712085893431256&amp;usg=AOvVaw1J0siaHHR3rPg-t1hh7cgC">TMultiMap</a></span><span class="c6 c9">&nbsp;is a variant of TMap that can store duplicate keys, with similar overall performance.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TSortedMap/&amp;sa=D&amp;source=editors&amp;ust=1712085893431570&amp;usg=AOvVaw3fJx5HTncTf2xIE_HPWQjK">TSortedMap</a></span><span>&nbsp;stores unique, automatically ordered elements, but as its underlying type is based on </span><span class="c13">TArray</span><span>&nbsp;it also shares its performance setbacks on adding and removing elements in big containers (O(n)), though finding is faster (O(Log n)). There is no variant of it for duplicate elements.</span></p><h6 class="c23" id="h.z7rivme4bl08"><span class="c24 c35">TList and TLinkedList</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl&amp;sa=D&amp;source=editors&amp;ust=1712085893432008&amp;usg=AOvVaw2wAOni77aaP4bmivZ6dk2v">Lists</a></span><span class="c6 c9">&nbsp;allow adding and removing elements with constant time speed and without reallocating memory (and as such without invalidating pointers), but random access is impossible and elements are not stored contiguously which increases memory usage.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>A </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TList/&amp;sa=D&amp;source=editors&amp;ust=1712085893432325&amp;usg=AOvVaw3sHXZWu_tdm9ll-rLDrfUD">TList</a></span><span>&nbsp;is just a struct that stores a </span><span class="c14">List</span><span class="c4">-&gt;</span><span class="c11">Element</span><span>&nbsp;and a </span><span class="c14">List</span><span class="c4">-&gt;</span><span class="c11">Next</span><span>&nbsp;</span><span class="c6 c9">pointer to the next one, as such only those two functions exist and it is up to you to create new elements and assign the pointers. Some examples to clarify:</span></p><p class="c5"><span class="c10">// Creating</span></p><p class="c5"><span class="c13">TList</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;* </span><span class="c14">NewElement </span><span class="c4">= </span><span class="c8">new </span><span class="c13">TList</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;(</span><span class="c15">10</span><span class="c4">, </span><span class="c8">nullptr</span><span class="c4">); </span><span class="c10">// New List with nullptr Next</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c10">// Emptying</span></p><p class="c5"><span class="c8">void </span><span class="c0">ExtractList</span><span class="c4">(</span><span class="c13">TList</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;* </span><span class="c14">List</span><span class="c4">, </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&amp; </span><span class="c14">OutArray</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">while </span><span class="c4">(</span><span class="c14">List</span><span class="c4">) { </span><span class="c10 c21">// While next list element is valid</span></p><p class="c5"><span class="c14">&nbsp; &nbsp; OutArray</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c14">List</span><span class="c4">-&gt;</span><span class="c11">Element</span><span class="c4">); </span><span class="c10 c21">// Copy current element value to OutArray</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c13">TList</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;* </span><span class="c14">Elem </span><span class="c4">= </span><span class="c14">List</span><span class="c4">; </span><span class="c10">// Store a pointer to the current element</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c14">List </span><span class="c4">= </span><span class="c14">List</span><span class="c4">-&gt;</span><span class="c11">Next</span><span class="c4">; </span><span class="c10">// Move to the next</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">delete </span><span class="c14">Elem</span><span class="c4">; </span><span class="c10">// Delete the current</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TLinkedList/&amp;sa=D&amp;source=editors&amp;ust=1712085893435712&amp;usg=AOvVaw2mSLlbTNWwadgwShVcCa6u">TLinkedList</a></span><span>&nbsp;is a more fleshed-out version with dedicated linking functions. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/TDoubleLinkedList/&amp;sa=D&amp;source=editors&amp;ust=1712085893435881&amp;usg=AOvVaw2K375UsPlEbDl09ec3Yavd">TDoubleLinkedList</a></span><span>&nbsp;</span><span>allows iterating backwards, like an </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/container/list&amp;sa=D&amp;source=editors&amp;ust=1712085893436032&amp;usg=AOvVaw3WujKqtQ2AD2yJU-YT3kdg">std::list</a></span><span>.</span></p><h6 class="c23" id="h.12xvmfhf6y86"><span class="c35">TCircularBuffer</span></h6><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.26/en-US/API/Runtime/Core/Containers/TCircularBuffer/&amp;sa=D&amp;source=editors&amp;ust=1712085893436415&amp;usg=AOvVaw0qEtuzwuUkmtQMVKA1oFNb">TCircularBuffer</a></span><span>&nbsp;is the underlying type of </span><span class="c13">TCircularQueue</span><span>. Useful if you want an equivalent to a FIFO </span><span class="c13">TQueue</span><span>&nbsp;with the constant time access of a </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Circular_buffer&amp;sa=D&amp;source=editors&amp;ust=1712085893436655&amp;usg=AOvVaw3gnoOpYRtKHk9Sw0QX76Zl">circular buffer</a></span><span>&nbsp;(doesn&rsquo;t shuffle elements around as it is fixed-sized), but without the multithreading overhead. A list is preferable if you want constant time access but dynamic size. Isn&rsquo;t really used much in the source files.</span></p><h4 class="c7" id="h.cd1d9cqzuzha"><span class="c35">Avoiding copies</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><h6 class="c23" id="h.n5v6tygqbpow"><span class="c35">MoveTemp</span></h6><p class="c16"><span>One of the greatest innovations of C++11 is </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/3106110/what-is-move-semantics&amp;sa=D&amp;source=editors&amp;ust=1712085893437280&amp;usg=AOvVaw2CeL23VOXPJIIMCiVZo2wl">Move Semantics</a></span><span class="c6 c9">, which allows displacing the contents of one container into another by cannibalizing it, instead of making a slow, deep copy of it.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>In Unreal, </span><span class="c13">MoveTemp</span><span class="c4">()</span><span class="c6 c9">&nbsp;can be used to move the contents of an entire container into another&rsquo;s (this does not invalidate the old container):</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">NewArray </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldArray</span><span class="c4">); </span><span class="c10">// &quot;=&quot; has constructor/assignment overloads</span></p><p class="c5"><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">NewSet </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldSet</span><span class="c4">); </span><span class="c10">// Old containers will be left empty</span></p><p class="c5"><span class="c13">TMap</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">, </span><span class="c8">FVector</span><span class="c4">&gt; </span><span class="c14">NewMap </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldMap</span><span class="c6 c4">);</span></p><p class="c5"><span class="c8">FMyStruct </span><span class="c14">NewStruct </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldStruct</span><span class="c4">); </span><span class="c10">// UStructs also have that overload</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>It also makes </span><span class="c0">Append</span><span class="c4">()</span><span>&nbsp;more efficient, as otherwise that function makes an expensive deep copy of the container:</span></p><p class="c5"><span class="c14">NewArray</span><span class="c4">.</span><span class="c0">Append</span><span class="c4">(</span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldArray</span><span class="c4">)); </span><span class="c10">// Moves OldArray&rsquo;s contents instead of copying it</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>But, and that&rsquo;s where Unreal&rsquo;s documentation is thoroughly lacking, you can also move individual elements in and out of containers with </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>, as the function overloads already exist for it!</span></p><p class="c5"><span class="c14">NewArray</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Elem</span><span class="c4">)); </span><span class="c10">// All insertion functions have move overloads</span></p><p class="c5"><span class="c14">NewSet</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Elem</span><span class="c6 c4">));</span></p><p class="c5"><span class="c14">NewMap</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c14">i</span><span class="c4">, </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Elem</span><span class="c6 c4">));</span></p><p class="c5"><span class="c14">Queue</span><span class="c4">.</span><span class="c0">Enqueue</span><span class="c4">(</span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Elem</span><span class="c6 c4">));</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>For moving out, it&rsquo;s more complex as the container </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/23118391/can-i-stdmove-an-element-out-of-a-stdvector&amp;sa=D&amp;source=editors&amp;ust=1712085893441455&amp;usg=AOvVaw0fkEo18gBxSig8c7pU8F6I">does not necessarily</a></span><span class="c6 c9">&nbsp;know the element has been moved out if you do not use a member function; you should usually remove the used index/key afterwards:</span></p><p class="c5"><span class="c8">int </span><span class="c14">i</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Find</span><span class="c4">(</span><span class="c14">Elem</span><span class="c4">);</span><span class="c8">&nbsp;auto </span><span class="c14">Out </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Array</span><span class="c4">[</span><span class="c14">i</span><span class="c4">]); </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">RemoveAt</span><span class="c4">(</span><span class="c14">i</span><span class="c4">); </span><span class="c10 c21">// or RemoveAtSwap</span></p><p class="c5"><span class="c13">FSetElementId </span><span class="c14">i </span><span class="c4">= </span><span class="c14">Set</span><span class="c4">.</span><span class="c0">FindId</span><span class="c4">(</span><span class="c14">Key</span><span class="c4">); </span><span class="c8">auto </span><span class="c14">Out </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Set</span><span class="c4">[</span><span class="c14">i</span><span class="c4">]); </span><span class="c14">Set</span><span class="c4">.</span><span class="c0">Remove</span><span class="c4">(</span><span class="c14">i</span><span class="c4">);</span></p><p class="c5"><span class="c8">auto </span><span class="c14">Out </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Map</span><span class="c4">[</span><span class="c14">Key</span><span class="c4">]); </span><span class="c14">Map</span><span class="c4">.</span><span class="c0">Remove</span><span class="c4">(</span><span class="c14">Key</span><span class="c4">);</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Some containers provide member functions which perform </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>&nbsp;internally:</span></p><p class="c5"><span class="c10">// With a return value (optimized away thanks to RVO)</span></p><p class="c5"><span class="c8">auto </span><span class="c14">Out</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Pop</span><span class="c4">(); </span><span class="c10 c21">// Returns the last element</span></p><p class="c5"><span class="c8">auto </span><span class="c14">Out </span><span class="c4">= </span><span class="c14">Map</span><span class="c4">.</span><span class="c0">FindAndRemoveChecked</span><span class="c4">(</span><span class="c14">Vector</span><span class="c4">); </span><span class="c10 c21">// Throws if not found</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c10">// With a parameter passed as reference (moves into the uninitialized ref)</span></p><p class="c5"><span class="c8">int </span><span class="c14">Out</span><span class="c4">; </span><span class="c14">Map</span><span class="c4">.</span><span class="c0">RemoveAndCopyValue</span><span class="c4">(</span><span class="c14">Key</span><span class="c4">, </span><span class="c14">Out</span><span class="c4">); </span><span class="c10">// Doesn&rsquo;t actually copy, nice misnomer</span></p><p class="c5"><span class="c8">int </span><span class="c14">Out</span><span class="c4">; </span><span class="c14">Queue</span><span class="c4">.</span><span class="c0">Dequeue</span><span class="c4">(</span><span class="c14">Out</span><span class="c4">);</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c10">// Simplified internals of Dequeue: Moves the popped item into the out ref</span></p><p class="c5"><span class="c8">bool </span><span class="c0">Dequeue</span><span class="c4">(</span><span class="c8">ItemType</span><span class="c4">&amp; </span><span class="c14">OutItem</span><span class="c4">){ </span><span class="c14">OutItem </span><span class="c4">= </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Popped</span><span class="c4">-&gt;</span><span class="c8">Item</span><span class="c4">); }</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Return Value Optimization (RVO) will optimize away the </span><span class="c8">return</span><span>&nbsp;values for you, so you do not need to do </span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Pop</span><span class="c4">())</span><span>. This also means you should avoid using </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/17473753/c11-return-value-optimization-or-move&amp;sa=D&amp;source=editors&amp;ust=1712085893446834&amp;usg=AOvVaw0ARAoIGzfDPz5oupTDL4VJ">move semantics on returns</a></span><span>. Note that you cannot move an </span><span class="c8">std</span><span class="c3">::</span><span class="c8">atomic</span><span class="c6 c9">, for very good reasons.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">On large types or structs, this is a godsend as not only can you avoid expensive copies, you can also grab and return discrete elements at your leisure too. An usage example is having a big container storing calculations results in game thread, handing out individual elements to async threads and grabbing them back when finished, without copies, mutexes, or risking having threads read into a container that could reallocate at any time.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Usually only nested dynamic containers (heap-allocated) or </span><span class="c8">structs</span><span>&nbsp;</span><span>containing dynamic containers benefit from </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>; it is wasted or even counter-productive on trivial types like </span><span class="c8">int</span><span>.</span></p><h6 class="c23" id="h.c6pk9ydxnkq1"><span class="c24 c35">new</span></h6><p class="c16"><span>The </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory/&amp;sa=D&amp;source=editors&amp;ust=1712085893447997&amp;usg=AOvVaw2FvyhU2GUWFP2RrWxoHmgW">new and delete</a></span><span class="c6 c9">&nbsp;keywords allow creating variables and containers directly on the heap, which means you are no longer bound by the scope of your function or class and can pass those pointers around classes freely.</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">Array </span><span class="c4">= </span><span class="c8">new </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;({</span><span class="c15">2</span><span class="c4">, </span><span class="c15">5</span><span class="c4">}); </span><span class="c10">// Array starting with two ints</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">ArrayB</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c8">new </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;(</span><span class="c13">MoveTemp</span><span class="c4">(</span><span class="c14">OldArray</span><span class="c4">)); </span><span class="c10">// Array starting with another&rsquo;s contents</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c14">Array</span><span class="c4">-&gt;</span><span class="c0">Add</span><span class="c4">(</span><span class="c15">10</span><span class="c4">); </span><span class="c10">// Safe to perform on a new TArray</span></p><p class="c5"><span class="c8">delete </span><span class="c14">Array</span><span class="c4">; </span><span class="c10">// Always delete after use!</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>However, this makes you enter the realm of </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://cplusplus.com/doc/tutorial/dynamic/&amp;sa=D&amp;source=editors&amp;ust=1712085893449885&amp;usg=AOvVaw2cfZUg9kosp_EBWWjVxOO0">dynamic memory management</a></span><span>, so always ensure to keep your pointers at hand and use </span><span class="c8">delete</span><span class="c6 c9">&nbsp;after you are done to avoid memory leaks. This otherwise only gets cleaned after the entire program shuts down.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>There are also instances in the engine&rsquo;s source of </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.geeksforgeeks.org/c-arrays/&amp;sa=D&amp;source=editors&amp;ust=1712085893450232&amp;usg=AOvVaw3l_frFU8x7Cts3PQD693mO">C-type arrays</a></span><span class="c6 c9">&nbsp;of TArrays.</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">CArrayOfTArray </span><span class="c4">= </span><span class="c8">new </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;[</span><span class="c15">8</span><span class="c4">]; </span><span class="c10 c21">// C array containing 8 TArrays</span></p><p class="c1"><span class="c21 c14 c34"></span></p><p class="c5"><span class="c14">CArrayOfTArray</span><span class="c4">[</span><span class="c15">2</span><span class="c4">].</span><span class="c0">Add</span><span class="c4">(</span><span class="c15">10</span><span class="c4">);</span></p><p class="c5"><span class="c8">delete</span><span class="c4">[]</span><span class="c8">&nbsp;</span><span class="c14">CArrayOfTArray</span><span class="c4">; </span><span class="c10 c21">// Use delete[] instead</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Call </span><span class="c8">delete</span><span class="c4">[]</span><span>&nbsp;instead in </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/4670782/the-difference-between-delete-and-delete-in-c&amp;sa=D&amp;source=editors&amp;ust=1712085893451687&amp;usg=AOvVaw3RCW1Vf18Ja93ioguPp4Ue">such a case</a></span><span class="c6 c9">.</span></p><h6 class="c23" id="h.y8699u6fl3j"><span class="c24 c35">FMemory</span></h6><p class="c16"><span>The </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/&amp;sa=D&amp;source=editors&amp;ust=1712085893452101&amp;usg=AOvVaw1KJBdjqbalLIy850vekd8l">TArray wiki page</a></span><span>&nbsp;has an interesting example which uses </span><span class="c8">FMemory</span><span>&nbsp;to copy a C array&rsquo;s contents into a </span><span class="c13">TArray</span><span>:</span></p><p class="c5"><span class="c13">int32 </span><span class="c14">In</span><span class="c4">[] = { </span><span class="c15">2</span><span class="c4">, </span><span class="c15">3</span><span class="c4">, </span><span class="c15">5</span><span class="c4">, </span><span class="c15">7 </span><span class="c6 c4">};</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">int32</span><span class="c4">&gt; </span><span class="c14">Out</span><span class="c6 c4">;</span></p><p class="c5"><span class="c14">Out</span><span class="c4">.</span><span class="c0">AddUninitialized</span><span class="c4">(</span><span class="c15">4</span><span class="c6 c4">);</span></p><p class="c5"><span class="c8">FMemory</span><span class="c3">::</span><span class="c0">Memcpy</span><span class="c4">(</span><span class="c14">Out</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(), </span><span class="c14">In</span><span class="c4">, </span><span class="c15">4</span><span class="c4">*</span><span class="c8">sizeof</span><span class="c4">(</span><span class="c13">int32</span><span class="c4">));</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>With bigger types where moving is more efficient, you can replace </span><span class="c0">Memcpy</span><span class="c4">()</span><span>&nbsp;with </span><span class="c0">Memmove</span><span class="c4">()</span><span>&nbsp;and use it as an alternative to </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>&nbsp;for move semantics:</span></p><p class="c5"><span class="c8">FMemory</span><span class="c3">::</span><span class="c0">Memmove</span><span class="c4">(</span><span class="c14">Out</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(), </span><span class="c14">In</span><span class="c4">, </span><span class="c15">4</span><span class="c4">*</span><span class="c8">sizeof</span><span class="c4">(</span><span class="c13">int32</span><span class="c6 c4">));</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>There are other interesting functions, such as </span><span class="c0">Memzero</span><span class="c4">()</span><span>&nbsp;to zero-out a range of elements, or</span><span>&nbsp;</span><span class="c0">Malloc</span><span class="c4">()</span><span>&nbsp;and </span><span class="c0">Free</span><span class="c4">()</span><span>&nbsp;which replace C++&rsquo;s native malloc functions. </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://unrealcommunity.wiki/garbage-collection-and-dynamic-memory-allocation-u29878mo&amp;sa=D&amp;source=editors&amp;ust=1712085893455266&amp;usg=AOvVaw0qA2kNXX4XoifxRkrNNV4n">More info</a></span><span>.</span></p><h6 class="c23" id="h.5gv1f9b6d3yq"><span class="c24 c35">Containers reallocation</span></h6><p class="c16"><span>An </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span>&nbsp;can be made to reallocate on grow through move semantics, if the element&rsquo;s class it contains has both its destructor and move constructor declared with </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/8001823/how-to-enforce-move-semantics-when-a-vector-grows&amp;sa=D&amp;source=editors&amp;ust=1712085893455831&amp;usg=AOvVaw2FRQd7aTS62mz8wkrMb-BW">noexcept</a></span><span>&nbsp;(or if that class is </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://quuxplusone.github.io/blog/2023/03/03/relocate-algorithm-design/&amp;sa=D&amp;source=editors&amp;ust=1712085893455980&amp;usg=AOvVaw0Dle5bXVOJ4vlnjvZX9QuT">trivial</a></span><span>&nbsp;or </span><span class="c8">default</span><span>-constructed); otherwise the vector will perform </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://quuxplusone.github.io/blog/2022/08/26/vector-pessimization/&amp;sa=D&amp;source=editors&amp;ust=1712085893456184&amp;usg=AOvVaw1dCG1ReEZI4iSn8o0tdupy">pessimization</a></span><span class="c6 c9">&nbsp;and use copy reallocations.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>With Unreal containers, you will not see </span><span class="c8">noexcept</span><span>&nbsp;being used in the source files; they use bespoke allocator implementations for all of their functions, passed through </span><span class="c8">FMemory</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The allocator used is declared in files like </span><span class="c39">WindowsPlatformMemory.cpp</span><span>, under </span><span class="c0">BaseAllocator</span><span class="c4">()</span><span>: Shipping builds default to </span><span class="c15">binned2</span><span>&nbsp;(a bin malloc), and the Editor to </span><span class="c15">TBB</span><span>&nbsp;(Intel&rsquo;s Thread Building Blocks; scales with available processors). Also noteworthy is </span><span class="c15">binned3</span><span>&nbsp;(64-bit only), </span><span class="c15">Ansi</span><span>&nbsp;(default C malloc), and </span><span class="c15">Mimalloc</span><span>&nbsp;(Microsoft opensource malloc). </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://ikrima.dev/ue4guide/engine-programming/memory/allocators-malloc/&amp;sa=D&amp;source=editors&amp;ust=1712085893457211&amp;usg=AOvVaw3ylS10vvcb35nVJZvevK9l">More info</a></span><span>.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Each allocator implements its own version of </span><span class="c0">Realloc</span><span class="c4">()</span><span>&nbsp;as declared in </span><span class="c39">MemoryBase.h</span><span>, which in turns calls </span><span class="c0">TryRealloc</span><span class="c4">()</span><span>. Most (</span><span class="c15">binned2</span><span>&nbsp;included) use </span><span class="c8">FMemory</span><span class="c3">::</span><span class="c0">Memcpy</span><span class="c4">()</span><span>, while </span><span class="c15">TBB</span><span>&nbsp;calls the lib&rsquo;s </span><span class="c0">scalable_aligned_realloc</span><span class="c4">()</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This means that for practical purposes Unreal containers will reallocate by copy when resizing; and therefore why it is notably advantageous to </span><span class="c0">Reserve</span><span class="c4">()</span><span>&nbsp;your TArrays and make smart uses of </span><span class="c13">MoveTemp</span><span class="c4">()</span><span>. Otherwise, if you </span><span class="c34">really</span><span>&nbsp;need it, you could fallback on </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span>&nbsp;as it does support move reallocation.</span></p><h3 class="c29" id="h.a9np1ch06vy"><span class="c47">2. Code </span><span class="c37 c47">and Loops</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">A foreword: As a general rule, code compiled in DebugGame configuration will be slower than in Development Editor, which in turn is slower than standalone Shipping builds.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>An accurate way to test your speeds is using </span><span class="c8">std</span><span class="c3">::</span><span class="c8">chrono</span><span class="c6 c9">:</span></p><p class="c5"><span class="c6 c8">#pragma once</span></p><p class="c5"><span class="c8">#include </span><span class="c39">&lt;chrono&gt;</span></p><p class="c5"><span class="c8">using namespace std</span><span class="c3">::</span><span class="c8">chrono</span><span class="c4">;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">class </span><span class="c13">Timer </span><span class="c6 c4">{</span></p><p class="c5"><span class="c13">&nbsp; time_point</span><span class="c4">&lt;</span><span class="c13">high_resolution_clock</span><span class="c4">&gt; </span><span class="c11">t1</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">&nbsp; void </span><span class="c0">start</span><span class="c4">() { </span><span class="c11">t1 </span><span class="c4">= </span><span class="c13">high_resolution_clock</span><span class="c3">::</span><span class="c0">now</span><span class="c6 c4">(); }</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">&nbsp; float </span><span class="c0">stop</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; auto </span><span class="c14">t2 </span><span class="c4">= </span><span class="c13">high_resolution_clock</span><span class="c3">::</span><span class="c0">now</span><span class="c6 c4">();</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; return</span><span class="c4">&nbsp;</span><span class="c13">duration_cast</span><span class="c4">&lt;</span><span class="c13">microseconds</span><span class="c4">&gt;(</span><span class="c14">t2 </span><span class="c4">- </span><span class="c11">t1</span><span class="c4">).</span><span class="c0">count</span><span class="c6 c4">();</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">};</span></p><h4 class="c7" id="h.eu2jnp4wnzh6"><span class="c31">Optimizing containers</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>If you&rsquo;re reusing containers, consider declaring those as member variables to avoid reconstructing them entirely on every function iteration, and using </span><span class="c0">Reset</span><span class="c4">()</span><span>&nbsp;instead of </span><span class="c0">Empty</span><span class="c4">()</span><span>&nbsp;to keep the previous memory allocation. Using </span><span class="c0">Init</span><span class="c4">()</span><span>&nbsp;to initialize with a specific value is also somewhat slower than </span><span class="c0">SetNum</span><span class="c4">()</span><span>.</span></p><h6 class="c23" id="h.ygalms2yy3tl"><span class="c22">Accessing methods</span></h6><p class="c16"><span>There are three ways to iterate through containers directly, without using </span><span class="c0">Add</span><span class="c4">()</span><span>&nbsp;or the </span><span class="c4">[]</span><span class="c6 c9">&nbsp;operator:</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>With a simple </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.2/en-US/API/Runtime/Core/Containers/TArray/GetData/1/&amp;sa=D&amp;source=editors&amp;ust=1712085893463232&amp;usg=AOvVaw32sRrnHQiTPo5zOYbVmeEt">pointer</a></span><span class="c6 c9">:</span></p><p class="c5"><span class="c8">auto </span><span class="c14">start</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(); </span><span class="c10 c21">// Equivalent to std vector.data()</span></p><p class="c5"><span class="c8">auto </span><span class="c14">end</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">() + </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Num</span><span class="c4">(); </span><span class="c10">// Equivalent to std &amp;vector.back()</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>With a </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Containers/TIndexedContainerIterator/&amp;sa=D&amp;source=editors&amp;ust=1712085893464358&amp;usg=AOvVaw2ugPd9Y2VYzZwrQJ79uGnY">generic iterator</a></span><span class="c6 c9">:</span></p><p class="c5"><span class="c8">auto </span><span class="c14">start</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">CreateIterator</span><span class="c4">(); </span><span class="c10 c21">// TIndexedContainerIterator</span></p><p class="c5"><span class="c8">auto </span><span class="c14">end</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">C</span><span class="c0">reateIterator</span><span class="c4">(); </span><span class="c14">end</span><span class="c4">.</span><span class="c0">SetToEnd</span><span class="c4">();</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>With a </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://docs.unrealengine.com/5.2/en-US/API/Runtime/Core/Containers/TCheckedPointerIterator/&amp;sa=D&amp;source=editors&amp;ust=1712085893465481&amp;usg=AOvVaw0JEOf26C3eSoJHC4kKzPQb">checked iterator</a></span><span class="c6 c9">&nbsp;which checks against the container resizing during operation, but is slightly slower:</span></p><p class="c5"><span class="c8">auto </span><span class="c14">start</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">begin</span><span class="c4">(); </span><span class="c10">// TCheckedPointerIterator</span></p><p class="c5"><span class="c8">auto </span><span class="c14">end</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">end</span><span class="c4">();</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This last iterator is missing most of the expected functionality however, as it is primarily intended to be the underlying structure of </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.unrealengine.com/en-US/blog/ranged-based-for-loops&amp;sa=D&amp;source=editors&amp;ust=1712085893466407&amp;usg=AOvVaw1ka2fXi9fceBcvhR-oCfc1">range-based for loops</a></span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>In all three cases, note the difference between </span><span class="c34">assigning</span><span>&nbsp;a value and </span><span class="c34">moving</span><span>&nbsp;the pointer or iterator:</span></p><p class="c5"><span class="c4">*</span><span class="c14">start </span><span class="c4">+= </span><span class="c15">1</span><span class="c4">; </span><span class="c10 c21">// Current element&#39;s value += 1</span></p><p class="c5"><span class="c14">start </span><span class="c4">+= </span><span class="c15">1</span><span class="c4">; </span><span class="c10">// Pointer position += 1 (move to the next container element)</span></p><h6 class="c23" id="h.g8kg9xllgcc5"><span class="c22">Accessing efficiency</span></h6><p class="c16"><span>Let&rsquo;s assume a worst case scenario where you want a multidimensional </span><span class="c13">TArray</span><span class="c6 c9">&nbsp;of elements, and compare different implementations from slowest to fastest:</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c32">Slowest</span><span class="c6 c9">: Using nested containers. Convoluted to work with and nothing the compiler can do to optimize further.</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt;&gt; </span><span class="c14">Array</span><span class="c4">; </span><span class="c10">// 3D array using nesting</span></p><p class="c5"><span class="c10">// Let&rsquo;s assume Size is an FIntVector you&rsquo;ve used to SetNum() all the nested TArrays</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">x </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">x </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">; ++</span><span class="c14">x</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">y </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">y </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y</span><span class="c4">; ++</span><span class="c14">y</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Z</span><span class="c4">; ++</span><span class="c14">z</span><span class="c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c14">Array</span><span class="c4">[</span><span class="c14">x</span><span class="c4">][</span><span class="c14">y</span><span class="c4">][</span><span class="c14">z</span><span class="c4">] += </span><span class="c15">10</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c32">Average</span><span>: With a 1D array of cubed length, using the known dimensions in each axis to offset the reads and writes to emulate a multidimensional array. Easier to work with, </span><span class="c8">UPROPERTY</span><span>-compatible, lesser memory usage from having types within types within types, and the compiler can optimize the offsets to bitshifts if the </span><span class="c11">Size</span><span class="c6 c9">&nbsp;dimensions are multiples of 8.</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">Array</span><span class="c6 c4">;</span></p><p class="c5"><span class="c14">Array</span><span class="c4">.</span><span class="c0">SetNum</span><span class="c4">(</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">* </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">* </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Z</span><span class="c6 c4">);</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">x </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">x </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">; ++</span><span class="c14">x</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">y </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">y </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y</span><span class="c4">; ++</span><span class="c14">y</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Z</span><span class="c4">; ++</span><span class="c14">z</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c10">// Fastest when writing in sequential memory order; reorder the x/y/z loops if needed</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c14">Array</span><span class="c4">[</span><span class="c14">x</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">+ </span><span class="c14">y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">+ </span><span class="c14">z</span><span class="c4">] += </span><span class="c15">10</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c32">Fast</span><span>: Replacing the </span><span class="c4">[]</span><span>&nbsp;operator with a pointer to which you add the expected memory offset. Unreal&rsquo;s bracket operator is overloaded with bound-checking logic that makes it slower than an equivalent </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span class="c6 c9">&rsquo;s, so you can bypass that by accessing the memory location directly through pointers.</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">x </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">x </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">; ++</span><span class="c14">x</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">y </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">y </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y</span><span class="c4">; ++</span><span class="c14">y</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Z</span><span class="c4">; ++</span><span class="c14">z</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">()[</span><span class="c14">x</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">+ </span><span class="c14">y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">+ </span><span class="c14">z</span><span class="c4">] += </span><span class="c15">10</span><span class="c4 c6">;</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c10">// Or *(Array.GetData() + (x*Size.X*Size.Y + y*Size.X + z)) += 10;</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c32">Faster</span><span>: If you assume elements in your array are always stored and retrieved in the same order, you can actually abstract away the entire function for offsetting and write linearly through iterators, for example with a range-based for loop or with </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">begin</span><span class="c4">()</span><span class="c6 c9">.</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">auto</span><span class="c4">&amp; </span><span class="c14">i </span><span class="c3">: </span><span class="c14">Array</span><span class="c4">) { </span><span class="c10">// Assumes you will write AND read later in the same order</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c14">i </span><span class="c4">+= </span><span class="c15">10</span><span class="c4">; </span><span class="c10">// Uses a checked iterator </span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c32">Fastest</span><span>: Range-based for loops are slightly slower than regular ones, as the </span><span class="c13">TCheckedPointerIterator</span><span>&nbsp;they use has to always make sure the container wasn&rsquo;t resized while iterating. You can maximize speed by using a raw pointer to the array and a regular loop instead.</span></p><p class="c5"><span class="c8">auto </span><span class="c14">p </span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(); </span><span class="c10">// May sometimes be faster if moved inside the loop&rsquo;s scope</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Z</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; *</span><span class="c14">p </span><span class="c4">+= </span><span class="c15">10</span><span class="c4">; ++</span><span class="c14">p</span><span class="c4">; </span><span class="c10">// Assign the current element, then move to the next one</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Footnote: If you use </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span>, &nbsp;</span><span class="c14">vector</span><span class="c4">.</span><span class="c0">at</span><span class="c4">()</span><span>&nbsp;is slower than </span><span class="c14">vector</span><span class="c4">[]</span><span>&nbsp;as it also does bound-checking.</span></p><h6 class="c23" id="h.6ppsegacme2m"><span class="c22">Adding efficiency</span></h6><p class="c16"><span>Every time you call </span><span class="c0">Add</span><span class="c4">()</span><span class="c6 c9">, there&rsquo;s a chance the container exceeds its internal reserved space and decides to reallocate.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>If you are using regular functions such as </span><span class="c0">Add</span><span class="c4">()</span><span class="c6 c9">, you can reserve memory by big increments to reduce that impact:</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">Array</span><span class="c6 c4">;</span></p><p class="c5"><span class="c14">Array</span><span class="c4">.</span><span class="c0">Reserve</span><span class="c4">(</span><span class="c15">1024</span><span class="c4">); </span><span class="c10">// Guarantees there is enough memory for 1024 elements</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c15">1024</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c15">10</span><span class="c4">); </span><span class="c10">// No reallocation until the reserved memory is exceeded</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>If you are accessing through braces, iterators or pointers, use </span><span class="c0">SetNum</span><span class="c4">()</span><span>&nbsp;or </span><span class="c0">SetNumUninitialized</span><span class="c4">()</span><span class="c6 c9">, as you may otherwise run over elements outside the container&rsquo;s bounds.</span></p><p class="c5"><span class="c14">Array</span><span class="c4">.</span><span class="c0">SetNumUninitialized</span><span class="c4">(</span><span class="c15">1024</span><span class="c4">); </span><span class="c10">// Doesn&#39;t call the Constructor, faster</span></p><p class="c5"><span class="c8">auto </span><span class="c14">p </span><span class="c4">= </span><span class="c14">Array</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(); </span><span class="c10">// Call after SetNum(), otherwise this becomes nullptr!</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c15">1024</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; *</span><span class="c14">p </span><span class="c4">= </span><span class="c15">10</span><span class="c4">; ++</span><span class="c14">p</span><span class="c4">; </span><span class="c10">// *p has no initial value here, don&#39;t use +=</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Be warned that once you resize a container, all pointers toward it become invalid; either avoid the situation or grab them again after size changes.</span></p><h4 class="c7" id="h.wzkibubrlj8w"><span class="c31">Optimizing loops</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><h6 class="c23" id="h.y6vuiw1h8j52"><span class="c22">Variable types</span></h6><p class="c16"><span class="c8">int</span><span>&nbsp;and </span><span class="c13">size_t</span><span class="c6 c9">&nbsp;are platform-dependent, but on modern machines it&rsquo;s usually:</span></p><p class="c16"><span>- Signed 32-bit for </span><span class="c8">int</span><span class="c6 c9">, whether or not the platform supports 64-bit.</span></p><p class="c16"><span>- Unsigned for </span><span class="c13">size_t</span><span class="c6 c9">, 32 or 64-bit depending on the platform (always the biggest type supported).</span></p><p class="c16"><span class="c6 c9">Both can be as low as 16-bit on certain platforms, but it&rsquo;s unlikely you will ship Unreal on those.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c13">int8</span><span>, </span><span class="c13">int16</span><span>, </span><span class="c13">int32</span><span>&nbsp;</span><span>and </span><span class="c13">int64</span><span>&nbsp;(and their </span><span class="c13">uint</span><span>&nbsp;</span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/621290/what-is-the-difference-between-signed-and-unsigned-variables&amp;sa=D&amp;source=editors&amp;ust=1712085893485428&amp;usg=AOvVaw1y6YH-ySn0IITQd4_zM-oI">unsigned</a></span><span>&nbsp;equivalents) allow you to guarantee the size in a platform-agnostic way. They are simple aliases for respectively </span><span class="c8">char</span><span>, </span><span class="c8">short</span><span>, </span><span class="c8">int</span><span>&nbsp;(or </span><span class="c8">long</span><span>) </span><span>and </span><span class="c8">long long</span><span>. </span><span class="c13">int32</span><span>-likes use Unreal-defined aliases, while the suffixed </span><span class="c13">int32_t</span><span>&nbsp;use std ones.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c8">int</span><span>&nbsp;is usually the fastest signed type and </span><span class="c13">size_t</span><span>&nbsp;the fastest unsigned one, as both scale to best fit a given platform&rsquo;s memory register. Smaller types are not faster but take less memory, while types bigger than the platform&rsquo;s register are slower as the CPU has to use instructions to &lsquo;emulate&rsquo; a size it doesn&rsquo;t natively support. Types such as </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/35055042/difference-between-uint8-t-uint-fast8-t-and-uint-least8-t&amp;sa=D&amp;source=editors&amp;ust=1712085893486360&amp;usg=AOvVaw3ES1LtuOxHkOKGp38EWcSH">int_fast8_t</a></span><span>&nbsp;guarantee fastest execution with at least n bits (usually just </span><span class="c8">int</span><span>).</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Using explicit casts such as </span><span class="c8">static_cast</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;(</span><span class="c14">MyEnum</span><span class="c4">)</span><span>&nbsp;adds no overhead at runtime, beside the inherent </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/37306000/performance-overhead-of-typecasting-variables-in-c&amp;sa=D&amp;source=editors&amp;ust=1712085893486961&amp;usg=AOvVaw284lQWU-1ViKpggwSBjwAB">cost of the conversion</a></span><span class="c6 c9">&nbsp;itself.</span></p><h6 class="c23" id="h.mhdnbkq9srqk"><span class="c22">const</span></h6><p class="c16"><span>Most articles online aim toward </span><span class="c8">const</span><span>&nbsp;being </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://theartofmachinery.com/2019/08/12/c_const_isnt_for_performance.html&amp;sa=D&amp;source=editors&amp;ust=1712085893487401&amp;usg=AOvVaw3Bj9jy9YiHLRW191NzIdcF">insignificant</a></span><span>&nbsp;for performance concerns, but it helps clarify the intent in your code. </span><span class="c8">const</span><span>&nbsp;(runtime) or </span><span class="c8">constexpr</span><span>&nbsp;(compile-time) member or global variables however are useful, as they </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/3435026/can-const-correctness-improve-performance&amp;sa=D&amp;source=editors&amp;ust=1712085893487690&amp;usg=AOvVaw24PnFDtewyF1BJs-lUrHIs">get inlined</a></span><span class="c6 c9">&nbsp;into code instead of using address calls to check against the value having potentially changed.</span></p><h6 class="c23" id="h.1by063lb1co0"><span class="c22">Inlining</span></h6><p class="c16"><span class="c6 c9">Let&rsquo;s say you&rsquo;ve split away part of your loop logic into functions:</span></p><p class="c5"><span class="c10">// .cpp</span></p><p class="c5"><span class="c8">int </span><span class="c13">AMyClass</span><span class="c3">::</span><span class="c0">GetID</span><span class="c4">(</span><span class="c8">int </span><span class="c14">x</span><span class="c4">, </span><span class="c8">int </span><span class="c14">y</span><span class="c4">, </span><span class="c8">int </span><span class="c14">z</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c14">x</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">+ </span><span class="c14">y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">+ </span><span class="c14">z</span><span class="c4">; </span><span class="c10 c21">// Function will be called at runtime</span></p><p class="c5"><span class="c4">}</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">void </span><span class="c13">AMyClass</span><span class="c3">::</span><span class="c0">Loop</span><span class="c6 c4">() {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">&nbsp;</span><span class="c10">/* x, y, z */ </span><span class="c6 c4">) {</span></p><p class="c5"><span class="c14">&nbsp; &nbsp; </span><span class="c11">Array</span><span class="c4">[</span><span class="c0">GetID</span><span class="c4">(</span><span class="c14">x</span><span class="c4">, </span><span class="c14">y</span><span class="c4">, </span><span class="c14">z</span><span class="c4">)] += </span><span class="c15">10</span><span class="c6 c4">;</span></p><p class="c5"><span class="c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>If declared in the .cpp, there&rsquo;s a high chance your loop will run slower, as each iteration has the added cost of the function calls, and because the compiler cannot optimize and vectorize the loop as efficiently since the function is now a different structure in memory, or could make </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://johnnysswlab.com/loop-optimizations-taking-matters-into-your-hands/&amp;sa=D&amp;source=editors&amp;ust=1712085893490576&amp;usg=AOvVaw1-8vvAtki1oKEi0GEf_ao1">unexpected changes</a></span><span class="c6 c9">&nbsp;to member variables.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The solution is to </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893490881&amp;usg=AOvVaw35iIsQmvI9cFP_uEOwl0gw">inline</a></span><span class="c6 c9">&nbsp;the function, which is most easily done by moving it into the header:</span></p><p class="c5"><span class="c10">// .h</span></p><p class="c5"><span class="c8">inline int </span><span class="c0">GetID</span><span class="c4">(</span><span class="c8">int </span><span class="c14">x</span><span class="c4">, </span><span class="c8">int </span><span class="c14">y</span><span class="c4">, </span><span class="c8">int </span><span class="c14">z</span><span class="c4">) { </span><span class="c10">// inline keyword is redundant within a class body</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c14">x</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">+ </span><span class="c14">y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">+ </span><span class="c14">z</span><span class="c4">; </span><span class="c10 c21">// Code will be copied in place at compilation</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This will instead emplace entirely the code of the function at the location of the call when compiling. This effectively makes it as if you wrote it there yourself, and allows full optimizations to be applied. It is up to the compiler to decide to do it or not however; you can use the </span><span class="c8">FORCEINLINE</span><span class="c6 c9">&nbsp;to guarantee the behavior. Prefer inlining only functions that are relatively small and called repeatedly.</span></p><h6 class="c23" id="h.u6779ooc5kri"><span class="c22">Pointers and references</span></h6><p class="c16"><span>Prefer passing most function parameters other than the simplest types by reference (</span><span class="c8">FVector</span><span class="c4">&amp;</span><span>) or pointer (</span><span class="c8">FVector</span><span class="c4">*</span><span class="c6 c9">) if possible, this reduces the amount of expensive temporary copies at runtime. Both methods fare similarly in speed, so use whichever you prefer.</span></p><p class="c5"><span class="c8">int </span><span class="c0">GetID</span><span class="c4">(</span><span class="c8">const FVector</span><span class="c4">&amp;</span><span class="c8">&nbsp;</span><span class="c14">Vector</span><span class="c4">) { </span><span class="c10">// FVector* also works but requires dereferencing</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c14">Vector</span><span class="c4">.</span><span class="c18">X</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">Y </span><span class="c4">+ </span><span class="c14">Vector</span><span class="c4">.</span><span class="c18">Y</span><span class="c4">*</span><span class="c11">Size</span><span class="c4">.</span><span class="c18">X </span><span class="c4">+ </span><span class="c14">Vector</span><span class="c4">.</span><span class="c18">Z</span><span class="c4">;</span></p><p class="c5"><span class="c4">}</span></p><h6 class="c23" id="h.h3tsa23vmqf9"><span class="c22">Local variables</span></h6><p class="c16"><span>The compiler </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.ibm.com/docs/en/aix/7.1?topic%3Dimplementation-c-c-coding-style-best-performance&amp;sa=D&amp;source=editors&amp;ust=1712085893494318&amp;usg=AOvVaw2_7J4dbdzj04Clx7lxf5oK">cannot know</a></span><span class="c6 c9">&nbsp;that a member or global variable will not change while iterating, so making a local copy &lsquo;explicits&rsquo; that no checks against that are needed and improves performance.</span></p><p class="c5"><span class="c8">bool </span><span class="c14">bMyTest_l </span><span class="c4">= </span><span class="c11">bMyTest</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c43"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c15">1024</span><span class="c4">; ++</span><span class="c14">i</span><span class="c4">) {</span></p><p class="c5"><span class="c8">&nbsp; if </span><span class="c4">(</span><span class="c14">bMyTest_l</span><span class="c4">) { </span><span class="c10">// Compiler knows this won&#39;t change since it&#39;s local to the function</span></p><p class="c5"><span class="c4 c34">&nbsp; &nbsp; </span><span class="c10 c21">/* Code */</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><h6 class="c23" id="h.r51rv9qd8ozu"><span class="c47">S</span><span class="c22">coping</span></h6><p class="c16"><span>Declaring variables in the </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/16139720/should-i-explicitely-scope-variables/16139786&amp;sa=D&amp;source=editors&amp;ust=1712085893496002&amp;usg=AOvVaw3KpoZkr8zwuBpBomT0JgZ0">innermost scope</a></span><span class="c6 c9">&nbsp;available reduces the memory footprint of your variables, and puts them closer to where they will be accessed.</span></p><p class="c5"><span class="c8">int </span><span class="c14">x1_A</span><span class="c4">; </span><span class="c10">// Has to hold resources for longer than necessary</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c15">1024</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c14">x1_A</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">x</span><span class="c4">+</span><span class="c15">1</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">&nbsp; int </span><span class="c14">x1_B</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c14">x</span><span class="c4">+</span><span class="c15">1</span><span class="c4">; </span><span class="c10 c21">// Only exists and accessible for the minimal required time</span></p><p class="c5"><span class="c10 c21">&nbsp; /* Code */</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c34">Do not</span><span class="c6 c9">&nbsp;move calculations to the innermost loop when not required. Sometimes refactoring loops to be more concise and readable actually degrades performance; the example below shows how the position of a single comparison can have a substantial impact:</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">x </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">x </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">x</span><span class="c4">) {</span></p><p class="c5"><span class="c10">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">y </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">y </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">y</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">z</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; &nbsp; if </span><span class="c4">(</span><span class="c14">bMyTest</span><span class="c4">) { </span><span class="c10">/* Code */</span><span class="c4">&nbsp;} </span><span class="c10">// bMyTest is compared 32768 times!</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; &nbsp; else</span><span class="c4">&nbsp;{</span><span class="c8">&nbsp;</span><span class="c10">/* Code */ </span><span class="c4">}</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c10">// Less concise, but substantially faster</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">x </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">x </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">x</span><span class="c4">) {</span></p><p class="c5"><span class="c10">&nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">y </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">y </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">y</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">if </span><span class="c4">(</span><span class="c14">bMyTest</span><span class="c4">) { </span><span class="c10">// bMyTest is compared &quot;only&quot; 1024 times</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; &nbsp; </span><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">z</span><span class="c4">) { </span><span class="c10">/* Code */</span><span class="c6 c4">&nbsp;}</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c8">else</span><span class="c4">&nbsp;{</span></p><p class="c5"><span class="c8">&nbsp; &nbsp; &nbsp; for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">z </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">z </span><span class="c4">&lt; </span><span class="c15">32</span><span class="c4">; ++</span><span class="c14">z</span><span class="c4">) { </span><span class="c10">/* Code */</span><span class="c6 c4">&nbsp;}</span></p><p class="c5"><span class="c6 c4">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c6 c4">&nbsp; }</span></p><p class="c5"><span class="c4">}</span></p><h6 class="c23" id="h.h2d85e8fcd1n"><span class="c22">Precalculating</span></h6><p class="c16"><span>Precalculate extremely aggressively. Every single calculation, assignment, pointer location or other logic done even just twice can benefit from being declared once and have its result reused; even the smallest </span><span class="c8">int</span><span class="c6 c9">.</span></p><p class="c5"><span class="c10">// x+1, y+1, z+1, GetID of those, AND the array pointer are inefficiently done twice</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c15">1024</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c8">&nbsp; if </span><span class="c4">(</span><span class="c11">Array</span><span class="c4">[</span><span class="c0">GetID</span><span class="c4">(</span><span class="c14">x</span><span class="c4">+</span><span class="c15">1</span><span class="c4">, </span><span class="c14">y</span><span class="c4">+</span><span class="c15">1</span><span class="c4">, </span><span class="c14">z</span><span class="c4">+</span><span class="c15">1</span><span class="c4">)] == </span><span class="c15">0</span><span class="c6 c4">)</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; </span><span class="c11">Array</span><span class="c4">[</span><span class="c0">GetID</span><span class="c4">(</span><span class="c14">x</span><span class="c4">+</span><span class="c15">1</span><span class="c4">, </span><span class="c14">y</span><span class="c4">+</span><span class="c15">1</span><span class="c4">, </span><span class="c14">z</span><span class="c4">+</span><span class="c15">1</span><span class="c4">)] += </span><span class="c15">10</span><span class="c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c10">// Less concise, but maximizes performance</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">&nbsp;</span><span class="c10">/* x, y, z */ </span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">const int </span><span class="c14">x1 </span><span class="c4">= </span><span class="c14">x</span><span class="c4">+</span><span class="c15">1; </span><span class="c8">const int </span><span class="c14">y1 </span><span class="c4">= </span><span class="c14">y</span><span class="c4">+</span><span class="c15">1;</span><span class="c4">&nbsp;</span><span class="c8">const int </span><span class="c14">z1 </span><span class="c4">= </span><span class="c14">z</span><span class="c4">+</span><span class="c15">1;</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">auto</span><span class="c4">*</span><span class="c8">&nbsp;</span><span class="c14">NextID </span><span class="c4">= </span><span class="c11">Array</span><span class="c4">[</span><span class="c0">GetID</span><span class="c4">(</span><span class="c14">x1</span><span class="c4">, </span><span class="c14">y1</span><span class="c4">, </span><span class="c14">z1</span><span class="c4">)];</span></p><p class="c5"><span class="c8">&nbsp; if </span><span class="c4">(*</span><span class="c14">NextID</span><span class="c4">&nbsp;== </span><span class="c15">0</span><span class="c6 c4">)</span></p><p class="c5"><span class="c4">&nbsp; &nbsp; *</span><span class="c14">NextID</span><span class="c4">&nbsp;+= </span><span class="c15">10</span><span class="c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Even subtle operations such as the implicit conversion of pointers to bools benefit from it:</span></p><p class="c5"><span class="c8">bool </span><span class="c14">PointerValid</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c11">MyPointer</span><span class="c28">&nbsp;</span><span class="c3">? </span><span class="c8">true </span><span class="c3">: </span><span class="c8">false</span><span class="c4">; </span><span class="c10">// True if MyPointer is not null</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">&nbsp;</span><span class="c10">/* x, y, z */ </span><span class="c6 c4">) {</span></p><p class="c5"><span class="c8">&nbsp; if </span><span class="c4">(</span><span class="c14">PointerValid</span><span class="c4">) { </span><span class="c10">/* Code */</span><span class="c4">&nbsp;} </span><span class="c10 c21">// Slightly faster than &quot;if (MyPointer)&quot;</span></p><p class="c5"><span class="c4">}</span></p><h6 class="c23" id="h.s037c7auoafb"><span class="c22">Ternary operator</span></h6><p class="c16"><span>The </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp&amp;sa=D&amp;source=editors&amp;ust=1712085893508121&amp;usg=AOvVaw3OaL1iX0pDLiqTCyadPJeR">ternary operator</a></span><span>, a more concise alternative to If/Else, is not in itself faster (both usually compile to the same assembly code), but allows assigning a variable in the same breath as it is declared, and by extension also declaring it as a </span><span class="c8">const</span><span>&nbsp;or reference</span><span>;</span><span>&nbsp;all of these plus </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/4192225/benefits-of-ternary-operator-vs-if-statement&amp;sa=D&amp;source=editors&amp;ust=1712085893508442&amp;usg=AOvVaw2M91OrDej8HvigQ6359PoI">other cases</a></span><span class="c6 c9">&nbsp;can improve performance.</span></p><p class="c5"><span class="c8">bool </span><span class="c14">ResultA</span><span class="c4">; </span><span class="c10">// Must be declared before being assigned due to scope restrictions</span></p><p class="c5"><span class="c8">if </span><span class="c4">(</span><span class="c11">MyCondition</span><span class="c4">) </span><span class="c14">ResultA </span><span class="c4">= </span><span class="c8">true</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">else </span><span class="c14">ResultA </span><span class="c4">= </span><span class="c8">false</span><span class="c6 c4">;</span></p><p class="c1"><span class="c6 c8"></span></p><p class="c5"><span class="c8">const bool</span><span class="c4">&amp;</span><span class="c8">&nbsp;</span><span class="c14">ResultB</span><span class="c28">&nbsp;</span><span class="c4">= </span><span class="c11">MyCondition</span><span class="c28">&nbsp;</span><span class="c3">? </span><span class="c8">true </span><span class="c3">: </span><span class="c8">false</span><span class="c4">; </span><span class="c10">// Allows declaring as const, &amp;, etc.</span></p><h6 class="c23" id="h.57dpspo7x4hr"><span class="c22">Pointer aliasing</span></h6><p class="c16"><span>In situations where two pointers in a loop </span><span class="c34">could</span><span>&nbsp;target overlapping memory regions, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://johnysswlab.com/loop-optimizations-taking-matters-into-your-hands/&amp;sa=D&amp;source=editors&amp;ust=1712085893510102&amp;usg=AOvVaw2vxZdrD6rjW3lIit6WzdYo">pointer aliasing</a></span><span>&nbsp;can occur which prevents a lot of usual loop optimizations from being performed. Use a </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c&amp;sa=D&amp;source=editors&amp;ust=1712085893510269&amp;usg=AOvVaw25OvEhfGWpbNIeLX0AHOiP">restrict</a></span><span class="c35">&nbsp;</span><span class="c6 c9">keyword in that case:</span></p><p class="c5"><span class="c8">int</span><span class="c4">* </span><span class="c8">__restrict </span><span class="c14">MyPointer</span><span class="c6 c4">;</span></p><p class="c2"><span class="c6 c8"></span></p><p class="c16"><span class="c8">__restrict</span><span>&nbsp;is for MSVC and </span><span class="c8">__restrict__</span><span>&nbsp;for GCC (</span><span class="c8">restrict</span><span>&nbsp;itself is deprecated in C++).</span></p><h4 class="c7" id="h.17z2huet310g"><span class="c31">Bitshifts</span></h4><hr><p class="c33"><span class="c6 c38 c35"></span></p><p class="c16"><span>Using </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/&amp;sa=D&amp;source=editors&amp;ust=1712085893511288&amp;usg=AOvVaw3VY-QFdHxDSAwq1iC5zBGA">bitwise operators</a></span><span>&nbsp;can yield increased performance in different ways:</span></p><h6 class="c23" id="h.4vevy2ogxsnw"><span class="c47">Multiplications and divisions</span></h6><p class="c16"><span>With unsigned integers, you can replace a multiplication, division or modulo operation by a power of 2 with </span><span class="c4">&lt;&lt;</span><span>,</span><span>&nbsp;</span><span class="c4">&gt;&gt;</span><span>&nbsp;or </span><span class="c4">&amp;</span><span class="c6 c9">, which in theory is faster:</span></p><p class="c5"><span class="c13">uint8</span><span class="c8">&nbsp;</span><span class="c14">a </span><span class="c4">= </span><span class="c15">2</span><span class="c4">; </span><span class="c10 c21">// (binary 00000010)</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c14">a </span><span class="c4">= </span><span class="c14">a </span><span class="c4">&lt;&lt; </span><span class="c15">3 </span><span class="c10 c21">// a leftshifted by 3 becomes 16 (00010000)</span></p><p class="c5"><span class="c14">a </span><span class="c4">= </span><span class="c14">a</span><span class="c14">&nbsp;</span><span class="c4">&gt;&gt; </span><span class="c15">2</span><span class="c4">; </span><span class="c10 c21">// a rightshifted by 2 becomes 4 (00000100)</span></p><p class="c5"><span class="c14">a </span><span class="c4">= </span><span class="c14">a </span><span class="c4">&amp; </span><span class="c15">1</span><span class="c4">; </span><span class="c10 c21">// Equivalent to &quot;a = x % 2;&quot;</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>This is most efficient when shifting by a static amount defined at compilation. Practically however, modern compilers will do the same optimizations </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.quora.com/Is-it-better-to-use-a-bitwise-operation-for-better-speed-or-use-common-multiplication-comparison-etc-for-better-readability-for-example-x-1-and-x-2&amp;sa=D&amp;source=editors&amp;ust=1712085893513273&amp;usg=AOvVaw0vXepu93sByfql3lL7zAhI">under the hood</a></span><span>&nbsp;if the conditions match (unsigned by powers of 2), and current CPU architectures have dedicated hardware to handle fast multiplications at similar speeds. Using shifts to perform divisions can still net </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://softwareengineering.stackexchange.com/questions/234967/speeds-of-multiplication-and-division&amp;sa=D&amp;source=editors&amp;ust=1712085893513469&amp;usg=AOvVaw2v_Q3f-LwNTb2FUOC50X5P">performance gains</a></span><span class="c6 c9">, and you can use uints with powers of 2 to help your compiler optimize.</span></p><h6 class="c23" id="h.ciux2dbvez0w"><span class="c22">Packed integers</span></h6><p class="c16"><span>Bitshifts and dedicated </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/cpp-bit-fields?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893513852&amp;usg=AOvVaw3KMpdeSAqpiVfR56ALQvUG">bitfield structs</a></span><span>&nbsp;allow packing multiple smaller values into a single </span><span class="c8">int</span><span>&nbsp;at different offsets; ex. 4 </span><span class="c13">int8</span><span>&nbsp;within an </span><span class="c13">int32</span><span class="c6 c9">. This reduces memory usage and copies, and is for example useful for sending compact vertex calculations to the GPU.</span></p><p class="c5"><span class="c13">uint32 </span><span class="c0">vertex</span><span class="c4">(</span><span class="c13">uint32 </span><span class="c14">x</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">y</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">z</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">type</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">light</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">norm</span><span class="c4">, </span><span class="c13">uint32 </span><span class="c14">ao</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c8">return </span><span class="c14">ao </span><span class="c4">&lt;&lt; </span><span class="c15">30 </span><span class="c4">| </span><span class="c14">norm </span><span class="c4">&lt;&lt; </span><span class="c15">27 </span><span class="c4">| </span><span class="c14">light </span><span class="c4">&lt;&lt; </span><span class="c15">23 </span><span class="c4">| </span><span class="c14">type </span><span class="c4">&lt;&lt; </span><span class="c15">18 </span><span class="c4">| </span><span class="c14">z</span><span class="c4">-</span><span class="c15">1</span><span class="c28">&nbsp;</span><span class="c4">&lt;&lt; </span><span class="c15">12 </span><span class="c4">| </span><span class="c14">y</span><span class="c4">-</span><span class="c15">1</span><span class="c28">&nbsp;</span><span class="c4">&lt;&lt; </span><span class="c15">6 </span><span class="c4">| </span><span class="c14">x</span><span class="c4">-</span><span class="c15">1</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Example taken from the </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/cgerikj/binary-greedy-meshing&amp;sa=D&amp;source=editors&amp;ust=1712085893516236&amp;usg=AOvVaw07bDXLE7XEfXKOIPl5IuF7">Binary Greedy Meshing</a></span><span>&nbsp;repo</span><span class="c6 c9">&nbsp;(good stuff).</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c15">1ULL</span><span>&nbsp;is equivalent to a </span><span class="c15">1</span><span>&nbsp;cast as an </span><span class="c8">unsigned long long</span><span>&nbsp;(i.e. </span><span class="c13">uint64</span><span>), which prevents a bitshift on an </span><span class="c8">int</span><span>&nbsp;(32-bit) from overflowing before being stored into a larger type.</span></p><p class="c5"><span class="c13">uint64 </span><span class="c14">a </span><span class="c4">= </span><span class="c15">0</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c8">int </span><span class="c14">shift </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">shift </span><span class="c4">&lt; </span><span class="c15">8</span><span class="c4">*</span><span class="c8">sizeof</span><span class="c4">(</span><span class="c13">uint64</span><span class="c4">); ++</span><span class="c14">shift</span><span class="c4">) { </span><span class="c10">// For all bits of a uint64</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c14">a </span><span class="c4">|= </span><span class="c15">1ULL </span><span class="c4">&lt;&lt; </span><span class="c14">shift</span><span class="c4">; </span><span class="c10">// Set true the current bit, by shifting a 1 read as &quot;uint64&quot;</span></p><p class="c5"><span class="c4">}</span></p><h6 class="c23" id="h.fbjls4e321i8"><span class="c47">Bitmasks</span></h6><p class="c16"><span>Bitwise </span><span class="c4">|</span><span>&nbsp;(OR) and </span><span class="c4">&amp;</span><span>&nbsp;(AND) can be used to create </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/18591924/how-can-i-use-a-bitmask&amp;sa=D&amp;source=editors&amp;ust=1712085893518364&amp;usg=AOvVaw1389bU6YR71o_5xQPx30Jd">bitmasks</a></span><span class="c6 c9">, which package bools as individual bits in an integer:</span></p><p class="c5"><span class="c8">constexpr </span><span class="c13">uint8 </span><span class="c14">FLAG_1</span><span class="c4">{ </span><span class="c15">0b00000001 </span><span class="c4">}; </span><span class="c10 c21">// binary representation with only bit 1 set</span></p><p class="c5"><span class="c8">constexpr </span><span class="c13">uint8 </span><span class="c14">FLAG_2</span><span class="c4">{ </span><span class="c15">0b00000010 </span><span class="c4">}; </span><span class="c10 c21">// binary representation with only bit 2 set</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c13">uint8 </span><span class="c14">Flags </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c10 c21">// Type must be large enough to hold the flags!</span></p><p class="c5"><span class="c14">Flags </span><span class="c4">|= </span><span class="c14">FLAG_1 </span><span class="c4">| </span><span class="c14">FLAG_2</span><span class="c4">; </span><span class="c10 c21">// Set the bits for FLAG_1 and FLAG_2 to 1</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c5"><span class="c8">if </span><span class="c4">((</span><span class="c14">Flags </span><span class="c4">&amp; (</span><span class="c14">FLAG_1 </span><span class="c4">| </span><span class="c14">FLAG_2</span><span class="c4">)) == (</span><span class="c14">FLAG_1 </span><span class="c4">| </span><span class="c14">FLAG_2</span><span class="c4">)) { </span><span class="c10 c21">// If an AND of the bits with FLAG_1 or FLAG_2 match either of those flags</span></p><p class="c5"><span class="c10">&nbsp; </span><span class="c14">Flags</span><span class="c28">&nbsp;</span><span class="c4">&amp;=</span><span class="c28">&nbsp;</span><span class="c14">FLAG_1</span><span class="c4">; </span><span class="c10 c21">// Set the bit for FLAG_1 to 0</span></p><p class="c5"><span class="c6 c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c4">|</span><span>&nbsp;and </span><span class="c4">&amp;</span><span>&nbsp;are used to compare masks, by returning respectively the OR and AND or every bit in the left and right operands. </span><span class="c4">|=</span><span>&nbsp;and </span><span class="c4">&amp;=</span><span>&nbsp;set single bits in the bitmask true or false, by comparing two operands and assigning the result to the left one in a single operation.</span></p><h6 class="c23" id="h.s2c9t31p24sp"><span class="c22">Bitsets</span></h6><p class="c16"><span>Using the STD library, the </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/utility/bitset&amp;sa=D&amp;source=editors&amp;ust=1712085893521214&amp;usg=AOvVaw23ujvWLlUNTD0biYalIc5F">std::bitset</a></span><span>&nbsp;and </span><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span class="c4">&lt;</span><span class="c8">bool</span><span class="c4">&gt;</span><span>&nbsp;containers package an array of bools as single bits, which minimizes space allocation and can improve speed; </span><span class="c8">std</span><span class="c3">::</span><span class="c13">bitset</span><span class="c6 c9">&nbsp;is faster but its size cannot be changed at runtime.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Unreal equivalents are </span><span class="c13">TStaticBitArray</span><span>&nbsp;and </span><span class="c13">TBitArray</span><span>; here&rsquo;s an example inspired by the engine&rsquo;s source:</span></p><p class="c5"><span class="c13">TBitArray</span><span class="c4">&lt;&gt; </span><span class="c14">Set</span><span class="c4">; </span><span class="c14">Set</span><span class="c4">.</span><span class="c0">Init</span><span class="c4">(</span><span class="c8">false</span><span class="c4">, </span><span class="c15">128</span><span class="c4">); </span><span class="c10 c21">// Or TStaticBitArray&lt;128&gt; StaticSet;</span></p><p class="c5"><span class="c14">Set</span><span class="c4">.</span><span class="c0">SetRange</span><span class="c4">(</span><span class="c15">10</span><span class="c4">, </span><span class="c15">6</span><span class="c4">, </span><span class="c8">true</span><span class="c4">); </span><span class="c10">// Sets alls bits from 10 to 10+6 to true</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">uint32 </span><span class="c14">NumWords </span><span class="c4">= </span><span class="c8">FBitSet</span><span class="c3">::</span><span class="c0">CalculateNumWords</span><span class="c4">(</span><span class="c14">Set</span><span class="c4">.</span><span class="c0">Num</span><span class="c4">()); </span><span class="c10 c21">// Number of uint32s in the bitset</span></p><p class="c5"><span class="c13">uint32 </span><span class="c14">Hash </span><span class="c4">= </span><span class="c14">NumWords</span><span class="c6 c4">;</span></p><p class="c5"><span class="c8">const </span><span class="c13">uint32</span><span class="c4">* </span><span class="c14">Data </span><span class="c4">= </span><span class="c14">Set</span><span class="c4">.</span><span class="c0">GetData</span><span class="c4">(); </span><span class="c10 c21">// Pointer to internal array of NumWords uint32s</span></p><p class="c5"><span class="c8">for </span><span class="c4">(</span><span class="c13">uint32 </span><span class="c14">i </span><span class="c4">= </span><span class="c15">0</span><span class="c4">; </span><span class="c14">i </span><span class="c4">&lt; </span><span class="c14">NumWords</span><span class="c4">; ++</span><span class="c14">i</span><span class="c6 c4">) {</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c14">Hash </span><span class="c4">^= </span><span class="c14">Data</span><span class="c4">[</span><span class="c14">i</span><span class="c4">]; </span><span class="c10 c21">// Bitwise XOR assignment: Compares each uint32 to the Hash and stores the XOR of individual bits</span></p><p class="c5"><span class="c4">}</span></p><h4 class="c7" id="h.f96gchhjcgbm"><span class="c47">SIMD</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.blog/2020/07/08/improving-performance-with-simd-intrinsics-in-three-use-cases/&amp;sa=D&amp;source=editors&amp;ust=1712085893524991&amp;usg=AOvVaw3t6X00WNOpRKL3kQ2I4ZkD">SIMD</a></span><span class="c25">&nbsp;</span><span>(Single Instruction Multiple Data), aka vector instructions, are the endgame of optimization for algebra: they allow you to process whole groups of floats or integers through large registers,</span><span class="c6 c9">&nbsp;improving speeds by factors of up to 4, 8 or even higher, depending on the situation.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>The main </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/31490853/are-different-mmx-sse-and-avx-versions-complementary-or-supersets-of-each-other&amp;sa=D&amp;source=editors&amp;ust=1712085893525457&amp;usg=AOvVaw1h2zP7g90UicXF7ZjT-Muh">instruction sets</a></span><span>&nbsp;are SSE, AVX, and AVX512, respectively using 128, 256 and 512-bit registers; which are available depends on the platform&rsquo;s hardware and the compiler settings. Just with SSE, you can for example process 2 </span><span class="c8">double</span><span>, 4 </span><span class="c8">float</span><span>&nbsp;or </span><span class="c13">int32</span><span>, or even 16 </span><span class="c13">int8</span><span class="c6 c9">&nbsp;for the price and clock cycles it would take to do one; double or quadruple that with AVX.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Unreal defaults to SSE due to it having the most widespread support. You can </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://forums.unrealengine.com/t/use-avx-instruction/30378&amp;sa=D&amp;source=editors&amp;ust=1712085893526015&amp;usg=AOvVaw3FPvP4LfbRoRrAZWAVnuLg">enable AVX</a></span><span>&nbsp;by adding </span><span class="c11">bUseAVX </span><span class="c4">= </span><span class="c8">true</span><span>&nbsp;to your project&rsquo;s </span><span class="c39">Build.cs</span><span>, but this also seems to require modifying the engine&rsquo;s </span><span class="c39">UE4Game.Target.cs</span><span>&nbsp;and recompiling it from source. Doing so makes the </span><span class="c39">VCToolChain.cs</span><span class="c6 c9">&nbsp;add the /arch:AVX flag to the compilation arguments for MSVC (this might therefore only apply to platforms that compile with the MSVC pipeline).</span></p><h6 class="c23" id="h.jbaov941dbqo"><span class="c22">Functions</span></h6><p class="c16"><span>SIMD is famously finicky to learn and implement, and spending time understanding </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/intrinsics/x86-intrinsics-list?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893526718&amp;usg=AOvVaw0WJRRWlN2LpQPN3q7NRhon">Intrinsics</a></span><span class="c6 c9">&nbsp;can be very daunting; writing an abstract on SIMD implementations would probably be as long as the entirety of the document up to this point, so we&rsquo;ll dispense with that.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Unreal wraps a number of SSE Intrinsics through </span><span class="c8">FMath</span><span>,</span><span>&nbsp;for example </span><span class="c8">FMath</span><span class="c3">::</span><span class="c0">RoundToInt</span><span class="c4">(</span><span class="c14">float</span><span class="c4">)</span><span>&nbsp;internally calls </span><span class="c8">UE4</span><span class="c3">::</span><span class="c8">SSE</span><span class="c3">::</span><span class="c13">RoundToInt</span><span class="c4">()</span><span>&nbsp;(or </span><span class="c8">SSE4</span><span>&nbsp;if available), which itself uses </span><span class="c13">_mm_cvt_ss2si</span><span class="c4">()</span><span>.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>To my knowledge intrinsics are never used directly in implementations in Unreal, they always pass through wrappers like </span><span class="c8">FMath</span><span>&nbsp;that check for the platform availability. I recommend using your IDE to search the source files for &lsquo;SSE&rsquo; and &lsquo;AVX&rsquo; if you want to learn more; also take a look at </span><span class="c39">sse_mathfun.h</span><span>&nbsp;and the </span><span class="c13">Align</span><span class="c4">()</span><span class="c6 c9">&nbsp;function. </span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>MSVC provides an </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/preprocessor/optimize?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893528264&amp;usg=AOvVaw1jikEnIErH6FSk7BwjFQC_">optimize pragma</a></span><span>&nbsp;to place before a function&rsquo;s definition. It might or might not have any effect at all due to which flags the default toolchain uses, or may be using optimizations that are already on by default. I didn&rsquo;t look into it much.</span></p><h6 class="c23" id="h.3g1wuiv1nol0"><span class="c47">Libraries</span></h6><p class="c16"><span>The &lsquo;default&rsquo; approach to vector instructions is through Intrinsics; as down to the machine and abstract as it gets. Intel Intrinsics work with both Intel and AMD CPUs as their underlying architectures are similar, but ARM (mobile) platforms use </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://developer.arm.com/documentation/102581/latest&amp;sa=D&amp;source=editors&amp;ust=1712085893528721&amp;usg=AOvVaw22cCA2-E-OKRC-l3CzJyEk">Neon Intrinsics</a></span><span class="c6 c9">&nbsp;instead.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Major compilers have extensions for vectorization pragmas and functions:</span></p><p class="c16"><span>- </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/parallel/openmp/openmp-simd?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893529088&amp;usg=AOvVaw0yGMrkWXceGP0QJ6hR6Ux4">OpenMP</a></span><span>&nbsp;in MSVC</span><span>. The </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/build/reference/openmp-enable-openmp-2-0-support?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712085893529280&amp;usg=AOvVaw1ONlEh2PHWEfptT-9Jarku">/openmp</a></span><span>&nbsp;compiler option might be disabled by default in Unreal, requiring recompiling from source.</span></p><p class="c16"><span>- </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/VcDevel/std-simd&amp;sa=D&amp;source=editors&amp;ust=1712085893529504&amp;usg=AOvVaw11sBLRjgCkVK9Jvh_C4IU4">std::simd</a></span><span>&nbsp;i</span><span>n GCC.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Third-party libraries also exist to abstract away some of the complexity of Intrinsics:</span></p><p class="c16"><span>- </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DOZwfVgnslDE&amp;sa=D&amp;source=editors&amp;ust=1712085893529967&amp;usg=AOvVaw3mwI5xQfVZUIPLp8l3TQ_k">Intel ISPC</a></span><span>&nbsp;for Unreal: In use in the engine&rsquo;s source. More info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.intel.com/content/www/us/en/developer/videos/simple-single-instruction-multiple-data-simd.html&amp;sa=D&amp;source=editors&amp;ust=1712085893530143&amp;usg=AOvVaw1pyz-4lv4pOOpZCKbUTtqT">there</a></span><span>, </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.intel.com/content/dam/develop/external/us/en/documents/simd-made-easy-with-intel-ispc.pdf&amp;sa=D&amp;source=editors&amp;ust=1712085893530300&amp;usg=AOvVaw3plZc6wl8hY_6ZvKIUnK-G">there</a></span><span>&nbsp;and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.intel.com/content/www/us/en/developer/articles/technical/intel-software-engineers-assist-with-unreal-engine-419-optimizations.html&amp;sa=D&amp;source=editors&amp;ust=1712085893530500&amp;usg=AOvVaw10N0cnQcmUAJJ4HaxhZ_qK">there</a></span><span class="c6 c9">. </span></p><p class="c16"><span>- </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/getnamo/opencl-ue4&amp;sa=D&amp;source=editors&amp;ust=1712085893530761&amp;usg=AOvVaw1Fkz0p3mtBANnuaSMmA6JR">OpenCL for Unreal</a></span><span class="c6 c9">: A standalone language with widerange SIMD functionalities.</span></p><p class="c16"><span>- </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/AlbertoBoldrini/simd-cpp&amp;sa=D&amp;source=editors&amp;ust=1712085893531007&amp;usg=AOvVaw3_jVG7_XX0BV_yMU-gu6hh">Light SIMD</a></span><span>&nbsp;and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://github.com/eatingtomatoes/pure_simd&amp;sa=D&amp;source=editors&amp;ust=1712085893531144&amp;usg=AOvVaw3gl5bXEdYigj_TRejaBswT">Pure SIMD</a></span><span class="c6 c9">: Wrappers for SIMD functionalities.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>In all cases, be sure that what you want to do isn&rsquo;t already doable through the platform-agnostic classes Unreal provides.</span></p><h3 class="c29" id="h.mlohavtyab2"><span class="c41">3. </span><span class="c37 c41">Modularity</span></h3><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">There&rsquo;s no hard rule against using std types (and the engine&rsquo;s source makes ample use of them), but for containers it is usually recommended to use Unreal&rsquo;s equivalents for a number of reasons:</span></p><p class="c16"><span>- They support the reflection system, and as such can be made accessible from blueprints, can safely store </span><span class="c13">UObjects</span><span>&nbsp;and </span><span class="c13">AActors</span><span class="c6 c9">, etc.</span></p><p class="c16"><span class="c6 c9">- They can be easily serialized (stored into memory).</span></p><p class="c16"><span class="c6 c9">- They have very good intercompatibility with the large swath of bespoke Unreal features.</span></p><p class="c16"><span>- They come in an immense breadth of types, as the wall of text before this might indicate. What you want to do is very probably supported, if not necessarily </span><span class="c34">documented</span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>But if you do not require the above, or want an easier time linking external libs to your projects, and so on, anything goes. For </span><span class="c6 c9">portability concerns, I doubt there&rsquo;s much of a difference; most std containers are in use in the source files too so your code wouldn&rsquo;t be the first to break. One notable difference is that std containers can be made to reallocate by move, whereas Unreal&rsquo;s are copy-only.</span></p><h4 class="c7" id="h.i6kch7mu4shp"><span class="c36 c41">Nested containers</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>A nested array resizing will never affect its parent; a container holding another or a </span><span class="c8">struct</span><span>&nbsp;of containers only stores objects (of compile-constant size) that hold pointers to their true heap-allocated data. More info </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://stackoverflow.com/questions/32488833/how-the-memory-allocation-works-for-nested-containers&amp;sa=D&amp;source=editors&amp;ust=1712085893533168&amp;usg=AOvVaw2fvnvF2rE8ZKLzwgwvRow9">there</a></span><span>&nbsp;and </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.reddit.com/r/cpp_questions/comments/8hcxh0/vector_of_vector_of_int_or_vector_of_pointer_to/&amp;sa=D&amp;source=editors&amp;ust=1712085893533345&amp;usg=AOvVaw0KDs2VgW_XtOGS8XPilPZa">there</a></span><span class="c6 c9">.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Some examples of nested containers usage found in the engine&rsquo;s source (and many more):</span></p><p class="c5"><span class="c10">// TArray of TArray/TSet/TMap (there&rsquo;s even some triple-nested TArrays)</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">A</span><span class="c4">; </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">B</span><span class="c4">; </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c13">TMap</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">,</span><span class="c8">FVector</span><span class="c4">&gt;&gt; </span><span class="c14">C</span><span class="c4">;</span></p><p class="c5"><span class="c10">// TQueue of TArray/TSet/TMap</span></p><p class="c5"><span class="c13">TQueue</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">D</span><span class="c4">; </span><span class="c13">TQueue</span><span class="c4">&lt;</span><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">E</span><span class="c4">; </span><span class="c13">TQueue</span><span class="c4">&lt;</span><span class="c13">TMap</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">,</span><span class="c8">FVector</span><span class="c4">&gt;&gt; </span><span class="c14">F</span><span class="c4">;</span></p><p class="c5"><span class="c10">// TStaticArray of TArray/TSet</span></p><p class="c5"><span class="c13">TStaticArray</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;,</span><span class="c15">32</span><span class="c4">&gt; </span><span class="c14">G</span><span class="c4">; </span><span class="c13">TStaticArray</span><span class="c4">&lt;</span><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;,</span><span class="c15">32</span><span class="c4">&gt; </span><span class="c14">H</span><span class="c4">;</span></p><p class="c5"><span class="c13">TSet</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">I</span><span class="c4">; </span><span class="c10">// TSet of TArray</span></p><p class="c5"><span class="c8">auto</span><span class="c4">* </span><span class="c14">J </span><span class="c4">= </span><span class="c8">new </span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;[</span><span class="c15">8</span><span class="c4">]; </span><span class="c10">// Dynamic C array of TArray</span></p><p class="c5"><span class="c13">TQueue</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">K</span><span class="c4">[</span><span class="c15">8</span><span class="c4">]; </span><span class="c10">// Static C array of TQueue</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Not found in the source files:</span></p><p class="c5"><span class="c13">TMap</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;,</span><span class="c8">FVector</span><span class="c4">&gt;</span><span class="c14">&nbsp;X</span><span class="c4">; </span><span class="c10">// TMap of TArray/TSet/TMap</span></p><p class="c5"><span class="c8">std</span><span class="c3">::</span><span class="c13">vector</span><span class="c4">&lt;</span><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt;&gt; </span><span class="c14">Y</span><span class="c4">; </span><span class="c10">// std::vector of TArray/TSet/TMap (or reverse)</span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">int</span><span class="c4">&gt; </span><span class="c14">Z</span><span class="c4">[</span><span class="c15">8</span><span class="c4">]; </span><span class="c10">// Static C array of TArray/TSet/TMap</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Unreal does not allow you to mark nested containers as </span><span class="c8">UPROPERTY</span><span>. </span><span class="c13">UObjects</span><span>&nbsp;and </span><span class="c13">AActors</span><span>&nbsp;that are not referenced in at least one variable or container marked as </span><span class="c8">UPROPERTY</span><span>&nbsp;are not GC-safe and can be </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://nerivec.github.io/old-ue4-wiki/pages/garbage-collection-dynamic-memory-allocation.html&amp;sa=D&amp;source=editors&amp;ust=1712085893540060&amp;usg=AOvVaw0OXs_vsWJghgFLgBYelep5">garbage-collected</a></span><span>&nbsp;at any time.</span></p><h4 class="c7" id="h.p23nog4dkaci"><span class="c36 c41">Structs</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span>Unlike nested containers, you can make a </span><span class="c13">TArray</span><span>&nbsp;of a </span><span class="c8">struct</span><span>&nbsp;and declare as member any variable or container, and mark it as </span><span class="c8">UPROPERTY</span><span class="c6 c9">&nbsp;to access it in blueprints.</span></p><p class="c5"><span class="c8">struct FMyStruct </span><span class="c4">{</span></p><p class="c5"><span class="c28">&nbsp; </span><span class="c0">FMyStruct</span><span class="c4">();</span></p><p class="c5"><span class="c13">&nbsp; TArray</span><span class="c4">&lt;</span><span class="c8">FVector</span><span class="c4">&gt; </span><span class="c18">MyArray</span><span class="c6 c4">;</span></p><p class="c5"><span class="c6 c4">};</span></p><p class="c1"><span class="c6 c4"></span></p><p class="c5"><span class="c13">TArray</span><span class="c4">&lt;</span><span class="c8">FMyStruct</span><span class="c4">&gt; </span><span class="c14">MyArrayOfStruct</span><span class="c4">; </span><span class="c10">// Blueprint-compatible</span></p><p class="c5"><span class="c14">MyArrayOfStruct</span><span class="c4">[</span><span class="c14">i</span><span class="c4">].</span><span class="c18">MyArray</span><span class="c4">.</span><span class="c0">Add</span><span class="c4">(</span><span class="c8">FVector</span><span class="c4">());</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">You can also define a Constructor and set default sizes for containers in newly created instances of your struct:</span></p><p class="c5"><span class="c8">inline FMyStruct</span><span class="c3">::</span><span class="c0">FMyStruct</span><span class="c4">() { </span><span class="c10">// Constructor of MyStruct</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c18">MyArray</span><span class="c4">.</span><span class="c0">SetNum</span><span class="c4">(</span><span class="c11">Size</span><span class="c4">); </span><span class="c10">// Size can be a global constexpr</span></p><p class="c5"><span class="c4">}</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>As with big containers, marking every sub-element in large structs as </span><span class="c8">UPROPERTY</span><span>&nbsp;can cause performance concerns. I have also personally encountered slowdowns when a custom constructor is defined for a </span><span class="c8">UStruct</span><span>; I haven&rsquo;t yet figured out the root of that.</span></p><h4 class="c7" id="h.x4u05xkk51yp"><span class="c41">Actors</span></h4><hr><p class="c33"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">Keep in mind that spawning Actors and Components is expensive (hundreds of milliseconds with 1k+ actors), even if they are nearly empty, and that operation cannot be multithreaded. If you can get away with one Actor spawning multiple Components, or even 1-Actor 1-Component setups, repeating the same functions that can reuse variables and containers, you will see benefits.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span class="c6 c9">ChildActors are more expensive to spawn than regular Actors, and creating Actors or Components through C++ is somewhat faster than through Blueprints.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c16"><span>Consider taking a look into </span><span class="c17"><a class="c12" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DkXd0VDZDSks&amp;sa=D&amp;source=editors&amp;ust=1712085893544389&amp;usg=AOvVaw0nz5rPhc8SmCipiTUCuYXo">ECS-like</a></span><span class="c6 c9">&nbsp;(Entity Component System) architectures.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c2"><span class="c6 c9"></span></p><hr><hr><p class="c33"><span class="c6 c9"></span></p><p class="c56"><span>I did say condensed.</span></p><p class="c2"><span class="c6 c9"></span></p><p class="c2"><span class="c6 c4"></span></p></body></html>